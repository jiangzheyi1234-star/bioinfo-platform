<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BLAST_CRASH_FIX.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BLAST_CRASH_FIX.md" />
              <option name="updatedContent" value="# BLAST 设置卡片崩溃问题修复说明&#10;&#10;## 问题描述&#10;&#10;**症状：** 点击 BLAST 环境设置卡片的&quot;验证并保存&quot;按钮后，程序立即崩溃退出  &#10;**退出代码：** -1073740791 (0xC0000409) - 表示严重错误（访问冲突/栈损坏）&#10;&#10;## 根本原因分析&#10;&#10;经过代码审查，发现了以下关键问题：&#10;&#10;### 1. **settings_page.py 中的致命缩进错误**&#10;&#10;**位置：** `ui/pages/settings_page.py` 第 143-150 行&#10;&#10;**问题代码：**&#10;```python&#10;def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;    # ... 其他代码 ...&#10;    self.ncbi_card.set_values(ncbi_api_key=str(merged.get(&quot;ncbi_api_key&quot;, &quot;&quot;) or &quot;&quot;))  &#10;&#10;    def _collect_components_config(self) -&gt; dict:  # ❌ 错误：嵌套在另一个方法内部&#10;         &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;    data = {}&#10;    # ... 其他代码 ...&#10;```&#10;&#10;**后果：**&#10;- `_collect_components_config` 方法被错误地定义在 `_apply_config_to_components` 方法内部&#10;- 当 `save_config()` 方法尝试调用 `self._collect_components_config()` 时找不到该方法&#10;- 导致 `AttributeError` 异常，但由于异常处理不当，程序直接崩溃&#10;&#10;**修复：**&#10;```python&#10;def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;    # ... 其他代码 ...&#10;    self.ncbi_card.set_values(ncbi_api_key=str(merged.get(&quot;ncbi_api_key&quot;, &quot;&quot;) or &quot;&quot;))&#10;&#10;def _collect_components_config(self) -&gt; dict:  # ✅ 正确：作为独立的类方法&#10;    &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;    data = {}&#10;    # ... 其他代码 ...&#10;```&#10;&#10;### 2. **blast_settings_card.py 中的信号重复连接**&#10;&#10;**位置：** `ui/widgets/blast_settings_card.py` 第 365-395 行&#10;&#10;**问题代码：**&#10;```python&#10;def _start_verification(self):&#10;    # ... 其他代码 ...&#10;    &#10;    # 连接信号&#10;    self._thread.started.connect(self._worker.run)&#10;    self._worker.finished.connect(self._on_verify_finished)&#10;&#10;    # 定义清理函数&#10;    def cleanup():&#10;        if hasattr(self, '_thread') and self._thread:&#10;            self._thread.quit()&#10;            self._thread.wait()&#10;            self._thread = None&#10;        # ... 其他代码 ...&#10;&#10;    # ❌ 问题：cleanup 函数也连接到 finished 信号&#10;    self._worker.finished.connect(cleanup)&#10;&#10;    self._thread.start()&#10;&#10;def _on_verify_finished(self, success, message):&#10;    # ... 处理验证结果 ...&#10;    self.request_save.emit()  # 触发保存&#10;    self._refresh_interaction_state()  # ❌ cleanup 会在此之后再次被调用&#10;```&#10;&#10;**后果：**&#10;- `finished` 信号被连接了两次：`_on_verify_finished` 和 `cleanup`&#10;- 验证完成后，两个槽函数都会被调用&#10;- 可能导致资源重复释放或访问已释放的资源&#10;- 在某些情况下造成内存访问冲突&#10;&#10;**修复：**&#10;```python&#10;def _start_verification(self):&#10;    # ... 其他代码 ...&#10;    &#10;    # 连接信号（只连接一次）&#10;    self._thread.started.connect(self._worker.run)&#10;    self._worker.finished.connect(self._on_verify_finished)&#10;    &#10;    # 线程完成后自动清理&#10;    self._thread.finished.connect(self._thread.deleteLater)&#10;&#10;    self._thread.start()&#10;&#10;def _on_verify_finished(self, success, message):&#10;    # ... 处理验证结果 ...&#10;    self.request_save.emit()&#10;    &#10;    # ✅ 正确：在槽函数内部完成清理&#10;    if hasattr(self, '_thread'):&#10;        self._thread.quit()&#10;        self._thread.wait()&#10;    &#10;    if hasattr(self, '_worker'):&#10;        self._worker.deleteLater()&#10;        &#10;    self._refresh_interaction_state()&#10;```&#10;&#10;### 3. **缺少异常处理保护**&#10;&#10;**问题：**&#10;- `save_config()` 方法没有 try-except 保护&#10;- 任何异常都会直接导致程序崩溃&#10;- 用户看不到错误信息&#10;&#10;**修复：**&#10;```python&#10;def save_config(self):&#10;    try:&#10;        data = self._collect_components_config()&#10;        self._write_config_file(data)&#10;        # ... 其他代码 ...&#10;    except Exception as e:&#10;        # 捕获并记录异常，防止崩溃&#10;        logging.error(f&quot;保存配置失败: {e}&quot;, exc_info=True)&#10;        try:&#10;            self.ssh_card.status_label.setText(f&quot;保存失败: {str(e)}&quot;)&#10;            self.ssh_card.status_label.setStyleSheet(&quot;color: #e74c3c;&quot;)&#10;        except Exception:&#10;            pass&#10;```&#10;&#10;## 修复清单&#10;&#10;### ✅ 已修复的文件&#10;&#10;1. **`ui/pages/settings_page.py`**&#10;   - ✅ 修复 `_collect_components_config` 方法的缩进&#10;   - ✅ 添加 `save_config` 方法的异常处理&#10;&#10;2. **`ui/widgets/blast_settings_card.py`**&#10;   - ✅ 移除重复的 cleanup 函数连接&#10;   - ✅ 在 `_on_verify_finished` 中正确清理资源&#10;&#10;3. **`ui/main.py`**&#10;   - ✅ 添加全局异常处理器&#10;   - ✅ 增强日志记录功能&#10;   - ✅ 崩溃时保存详细日志&#10;&#10;## 测试方法&#10;&#10;### 方法 1：使用测试脚本&#10;&#10;运行测试脚本验证修复：&#10;```bash&#10;python test_blast_settings_fix.py&#10;```&#10;&#10;操作步骤：&#10;1. 点击&quot;修改&quot;按钮&#10;2. 填写配置信息&#10;3. 点击&quot;验证并保存&quot;&#10;4. 观察是否正常工作（不应崩溃）&#10;&#10;### 方法 2：在实际应用中测试&#10;&#10;1. 启动应用程序：&#10;```bash&#10;python ui/main.py&#10;```&#10;&#10;2. 进入设置页面&#10;3. 连接 SSH&#10;4. 在 BLAST 设置卡片中：&#10;   - 点击&quot;修改&quot;&#10;   - 填写 BLAST 程序路径和数据库路径&#10;   - 点击&quot;验证并保存&quot;&#10;&#10;**预期结果：**&#10;- 不应崩溃&#10;- 如果验证失败，应显示错误信息&#10;- 如果验证成功，应保存配置并锁定界面&#10;- 日志文件中应有详细记录&#10;&#10;### 检查日志&#10;&#10;查看日志文件确认修复：&#10;```bash&#10;# 查看最新的应用日志&#10;cat logs/app_*.log | tail -50&#10;&#10;# 检查是否有崩溃日志&#10;ls -la logs/crash_*.log&#10;```&#10;&#10;如果修复成功，应该：&#10;- ✅ 不会生成新的 crash 日志&#10;- ✅ app 日志中能看到正常的保存流程&#10;- ✅ 没有 AttributeError 或 访问冲突错误&#10;&#10;## 技术细节&#10;&#10;### 问题 1 的技术解释&#10;&#10;Python 中方法的缩进定义了其作用域：&#10;&#10;```python&#10;class MyClass:&#10;    def method_a(self):&#10;        # method_a 的代码&#10;        &#10;        def method_b(self):  # ❌ 错误：这是嵌套函数，不是类方法&#10;            pass&#10;    &#10;    def method_c(self):  # ✅ 正确：这是类方法&#10;        pass&#10;```&#10;&#10;当 `method_b` 被错误地嵌套在 `method_a` 内部时：&#10;- 它只在 `method_a` 执行期间存在&#10;- 无法通过 `self.method_b()` 调用&#10;- 尝试调用会抛出 `AttributeError`&#10;&#10;### 问题 2 的技术解释&#10;&#10;PyQt6 信号-槽机制：&#10;&#10;```python&#10;# 每次调用 connect，都会添加一个新的连接&#10;signal.connect(slot1)  # 连接 1&#10;signal.connect(slot2)  # 连接 2&#10;&#10;# 当信号触发时，所有连接的槽都会被调用&#10;signal.emit()  # 调用 slot1()，然后调用 slot2()&#10;```&#10;&#10;问题场景：&#10;```python&#10;self._worker.finished.connect(self._on_verify_finished)  # 连接 1&#10;self._worker.finished.connect(cleanup)                   # 连接 2&#10;&#10;# 当验证完成时&#10;# 1. _on_verify_finished() 被调用&#10;#    - 可能触发 request_save 信号&#10;#    - 可能访问 self._thread&#10;# 2. cleanup() 被调用&#10;#    - 释放 self._thread&#10;#    - 如果 _on_verify_finished 还在运行，可能访问已释放的资源&#10;```&#10;&#10;### 退出代码 0xC0000409 的含义&#10;&#10;**0xC0000409 = STATUS_STACK_BUFFER_OVERRUN**&#10;&#10;这是 Windows 系统的安全机制，当检测到以下情况时会强制终止程序：&#10;- 栈缓冲区溢出&#10;- 破坏了栈保护 cookie&#10;- 访问已释放的内存&#10;- 重复释放内存&#10;&#10;在我们的情况下，最可能的原因是：&#10;- cleanup 函数重复释放 thread/worker&#10;- 在资源释放后仍然访问它们&#10;- 信号槽的重复调用导致栈状态异常&#10;&#10;## 预防措施&#10;&#10;为防止类似问题再次发生，建议：&#10;&#10;### 1. 代码规范&#10;- ✅ 使用 IDE 的自动格式化功能（如 Black）&#10;- ✅ 启用代码检查工具（如 Pylint, Flake8）&#10;- ✅ 进行代码审查&#10;&#10;### 2. 测试策略&#10;- ✅ 为关键功能编写单元测试&#10;- ✅ 在修改后进行回归测试&#10;- ✅ 使用调试器逐步执行代码&#10;&#10;### 3. 异常处理&#10;- ✅ 所有公共 API 方法都应有 try-except&#10;- ✅ 记录详细的错误日志&#10;- ✅ 向用户显示友好的错误消息&#10;&#10;### 4. 信号-槽管理&#10;- ✅ 避免重复连接同一个信号&#10;- ✅ 使用 `disconnect()` 清理不需要的连接&#10;- ✅ 在文档中标注信号的生命周期&#10;&#10;### 5. 资源管理&#10;- ✅ 使用 `deleteLater()` 而不是直接删除 Qt 对象&#10;- ✅ 确保 thread 在删除前已经 quit 和 wait&#10;- ✅ 避免在槽函数中删除发射信号的对象&#10;&#10;## 相关文件&#10;&#10;### 修复的核心文件&#10;- `ui/pages/settings_page.py` - 修复缩进错误和添加异常处理&#10;- `ui/widgets/blast_settings_card.py` - 修复信号重复连接&#10;- `ui/main.py` - 添加全局异常处理&#10;&#10;### 测试文件&#10;- `test_blast_settings_fix.py` - 验证修复的测试脚本&#10;&#10;### 日志文件&#10;- `logs/app_*.log` - 应用运行日志&#10;- `logs/crash_*.log` - 崩溃日志（修复后不应再生成）&#10;&#10;## 总结&#10;&#10;此次修复解决了三个严重问题：&#10;1. **方法缩进错误** - 导致方法找不到&#10;2. **信号重复连接** - 导致资源访问冲突&#10;3. **缺少异常处理** - 导致错误直接崩溃&#10;&#10;所有问题都已修复并添加了保护措施。修复后的代码更加健壮，能够优雅地处理错误而不会崩溃。&#10;&#10;---&#10;&#10;**修复完成时间：** 2026-01-18  &#10;**状态：** ✅ 已完成  &#10;**测试状态：** 待用户验证&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_blast_settings_fix.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_blast_settings_fix.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;测试 BLAST 设置卡片的保存功能&#10;验证修复是否有效&#10;&quot;&quot;&quot;&#10;import sys&#10;import os&#10;&#10;# 添加项目根目录到路径&#10;root_dir = os.path.dirname(os.path.abspath(__file__))&#10;if root_dir not in sys.path:&#10;    sys.path.append(root_dir)&#10;&#10;import logging&#10;logging.basicConfig(&#10;    level=logging.DEBUG,&#10;    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'&#10;)&#10;&#10;from PyQt6.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget&#10;from ui.widgets.blast_settings_card import BlastSettingsCard&#10;&#10;class TestWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;BLAST Settings Card 测试&quot;)&#10;        self.setGeometry(100, 100, 800, 600)&#10;        &#10;        # 创建中心部件&#10;        central_widget = QWidget()&#10;        self.setCentralWidget(central_widget)&#10;        &#10;        layout = QVBoxLayout(central_widget)&#10;        &#10;        # 模拟 SSH 客户端函数&#10;        def mock_ssh_client():&#10;            print(&quot;⚠️ 模拟 SSH 客户端 - 返回 None（需要真实 SSH 连接才能测试验证功能）&quot;)&#10;            return None&#10;        &#10;        # 添加 BLAST Settings Card&#10;        self.blast_card = BlastSettingsCard(mock_ssh_client)&#10;        layout.addWidget(self.blast_card)&#10;        &#10;        # 连接保存信号&#10;        self.blast_card.request_save.connect(self.on_save_requested)&#10;        &#10;        layout.addStretch()&#10;        &#10;        print(&quot;=&quot; * 60)&#10;        print(&quot;BLAST Settings Card 测试窗口&quot;)&#10;        print(&quot;=&quot; * 60)&#10;        print(&quot;1. 点击'修改'按钮进入编辑模式&quot;)&#10;        print(&quot;2. 填写配置信息&quot;)&#10;        print(&quot;3. 点击'验证并保存'按钮&quot;)&#10;        print(&quot;4. 观察是否出现崩溃&quot;)&#10;        print()&#10;        print(&quot;修复内容：&quot;)&#10;        print(&quot;- 修复了 settings_page.py 中的缩进错误&quot;)&#10;        print(&quot;- 修复了信号重复连接导致的资源冲突&quot;)&#10;        print(&quot;- 添加了异常处理保护&quot;)&#10;        print(&quot;=&quot; * 60)&#10;    &#10;    def on_save_requested(self):&#10;        print(&quot;✅ 接收到保存信号 - request_save.emit() 成功触发&quot;)&#10;        print(&quot; 模拟保存配置...&quot;)&#10;        &#10;        # 模拟保存逻辑&#10;        try:&#10;            values = self.blast_card.get_values()&#10;            print(f&quot;   - BLAST 程序路径: {values.get('blast_bin', '未设置')}&quot;)&#10;            print(f&quot;   - 远程数据库路径: {values.get('remote_db', '未设置')}&quot;)&#10;            print(f&quot;   - 远程工作目录: {values.get('remote_dir', '未设置')}&quot;)&#10;            print(&quot;✅ 配置保存成功（模拟）&quot;)&#10;        except Exception as e:&#10;            print(f&quot;❌ 保存失败: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;if __name__ == '__main__':&#10;    print(&quot;\n 启动测试程序...\n&quot;)&#10;    app = QApplication(sys.argv)&#10;    window = TestWindow()&#10;    window.show()&#10;    sys.exit(app.exec())&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/pages/settings_page.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/pages/settings_page.py" />
              <option name="originalContent" value="import json&#10;import os&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtWidgets import QLabel, QPushButton&#10;&#10;from config import DEFAULT_CONFIG&#10;from ui.page_base import BasePage&#10;from ui.widgets import SshSettingsCard, NcbiSettingsCard, BlastSettingsCard, LinuxSettingsCard&#10;from ui.widgets.styles import PAGE_HEADER_TITLE, BUTTON_SUCCESS, COLOR_BG_APP&#10;&#10;class SettingsPage(BasePage):&#10;    def __init__(self):&#10;        super().__init__(&quot;\u2699 \u8bbe\u7f6e&quot;)&#10;        if hasattr(self, &quot;label&quot;):&#10;            self.label.hide()&#10;&#10;        self.config_dir = os.path.join(os.getenv('APPDATA'), &quot;H2OMeta&quot;)&#10;        self.config_path = os.path.join(self.config_dir, &quot;config.json&quot;)&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;&#10;        self.setStyleSheet(f&quot;background-color: {COLOR_BG_APP};&quot;)&#10;&#10;        self.init_ui()&#10;        self.load_config()&#10;&#10;        # 启动即自动执行一次连接测试&#10;        QTimer.singleShot(1000, self.ssh_card.auto_check_on_start)&#10;&#10;    # -------------------------&#10;    # UI 构建：调度员&#10;    # -------------------------&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;调度员：只负责页面整体参数与模块调用顺序，不写任何卡片细节。&quot;&quot;&quot;&#10;        self.layout.setContentsMargins(40, 30, 40, 30)&#10;        self.layout.setSpacing(25)&#10;&#10;        self._init_header()&#10;        self._init_cards()&#10;        self._init_save_area()&#10;&#10;        self.layout.addStretch()&#10;&#10;    def _init_header(self):&#10;        header_title = QLabel(&quot;系统设置&quot;)&#10;        header_title.setStyleSheet(PAGE_HEADER_TITLE)&#10;        self.layout.addWidget(header_title)&#10;&#10;    def _init_cards(self):&#10;        # SSH 卡片&#10;        self.ssh_card = SshSettingsCard()&#10;        self.layout.addWidget(self.ssh_card)&#10;&#10;         # Linux 设置卡片&#10;        self.linux_card = LinuxSettingsCard()&#10;        self.layout.addWidget(self.linux_card)&#10;&#10;        # BLAST 数据库设置卡片 (新增)&#10;        # 传入 ssh_card 的 get_active_client 方法，以便它可以调用 SSH 进行验证&#10;        self.blast_card = BlastSettingsCard(self.ssh_card.get_active_client)&#10;        self.blast_card.request_save.connect(self.save_config)  # 连接保存信号&#10;        self.layout.addWidget(self.blast_card)&#10;&#10;        # NCBI 卡片&#10;        self.ncbi_card = NcbiSettingsCard()&#10;        self.ncbi_card.request_save.connect(self._save_ncbi_config)&#10;        self.layout.addWidget(self.ncbi_card)&#10;&#10;        # --- 核心联动：SSH 连接成功后，自动把 Client 传给 Linux 卡片 ---&#10;        self.ssh_card.connection_state_changed.connect(self._on_ssh_state_changed)&#10;       &#10;&#10;    def _init_save_area(self):&#10;        # 移除单独的保存按钮，因为现在保存功能集成在BLAST设置卡片中&#10;        pass&#10;&#10;    # -------------------------&#10;    # 对外能力：提供共享 SSHClient&#10;    # -------------------------&#10;    def get_active_client(self):&#10;        return self.ssh_card.get_active_client()&#10;&#10;    def set_global_lock(self, locked: bool, reason: str = &quot;SSH 正在使用中，系统设置已锁定&quot;) -&gt; None:&#10;        self.ssh_card.set_external_lock(locked, reason)&#10;        self.blast_card.set_external_lock(locked)&#10;        if hasattr(self.linux_card, &quot;_toggle_lock&quot;):&#10;            self.linux_card._toggle_lock(locked)&#10;        self.ncbi_card.set_external_lock(locked)&#10;&#10;    # -------------------------&#10;    # Config IO：标准化读写 + 组件同步&#10;    # -------------------------&#10;    def _read_config_file(self) -&gt; dict:&#10;        if not os.path.exists(self.config_path):&#10;            return {}&#10;        try:&#10;            with open(self.config_path, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;            return data if isinstance(data, dict) else {}&#10;        except Exception:&#10;            return {}&#10;&#10;    def _write_config_file(self, data: dict) -&gt; None:&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;        with open(self.config_path, 'w', encoding='utf-8') as f:&#10;            json.dump(data, f, ensure_ascii=False, indent=2)&#10;&#10;    def _default_config_for_ui(self) -&gt; dict:&#10;        &quot;&quot;&quot;补充默认配置项&quot;&quot;&quot;&#10;        return {&#10;            &quot;server_ip&quot;: DEFAULT_CONFIG.get(&quot;ip&quot;, &quot;&quot;),&#10;            &quot;ssh_user&quot;: DEFAULT_CONFIG.get(&quot;user&quot;, &quot;&quot;),&#10;            &quot;ssh_pwd&quot;: DEFAULT_CONFIG.get(&quot;pwd&quot;, &quot;&quot;),&#10;            &quot;ncbi_api_key&quot;: DEFAULT_CONFIG.get(&quot;ncbi_api_key&quot;, &quot;&quot;),&#10;            &quot;remote_db&quot;: DEFAULT_CONFIG.get(&quot;remote_db&quot;, &quot;&quot;), # 新增项&#10;            &quot;blast_bin&quot;: DEFAULT_CONFIG.get(&quot;blast_bin&quot;, &quot;&quot;), # 新增项&#10;            &quot;remote_dir&quot;: DEFAULT_CONFIG.get(&quot;remote_dir&quot;, &quot;&quot;), # 新增&#10;        }&#10;&#10;    def _load_config_merged(self) -&gt; dict:&#10;        merged = self._default_config_for_ui()&#10;        merged.update({k: v for k, v in self._read_config_file().items() if v is not None})&#10;        return merged&#10;&#10;    def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;        &quot;&quot;&quot;将加载的配置分发给各卡片&quot;&quot;&quot;&#10;        self.ssh_card.set_values(&#10;            server_ip=str(merged.get(&quot;server_ip&quot;, &quot;&quot;) or &quot;&quot;),&#10;            ssh_user=str(merged.get(&quot;ssh_user&quot;, &quot;&quot;) or &quot;&quot;),&#10;            ssh_pwd=str(merged.get(&quot;ssh_pwd&quot;, &quot;&quot;) or &quot;&quot;),&#10;        )&#10;        # 为 Linux 卡片设置初始值&#10;        self.linux_card.set_values(&#10;            project_path=str(merged.get(&quot;linux_project_path&quot;, &quot;&quot;) or &quot;&quot;),&#10;            conda_env=str(merged.get(&quot;conda_env_path&quot;, &quot;&quot;) or &quot;&quot;)&#10;        )&#10;        self.blast_card.set_values(&#10;            remote_db=str(merged.get(&quot;remote_db&quot;, &quot;&quot;) or &quot;&quot;),&#10;            blast_bin=str(merged.get(&quot;blast_bin&quot;, &quot;&quot;) or &quot;&quot;),&#10;            remote_dir=str(merged.get(&quot;remote_dir&quot;, &quot;&quot;) or &quot;&quot;)&#10;        )&#10;        self.ncbi_card.set_values(ncbi_api_key=str(merged.get(&quot;ncbi_api_key&quot;, &quot;&quot;) or &quot;&quot;))&#10;&#10;        def _collect_components_config(self) -&gt; dict:&#10;             &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;        data = {}&#10;        data.update(self.ssh_card.get_values())&#10;        data.update(self.blast_card.get_values()) # 收集新卡片数据&#10;        data.update(self.linux_card.get_values())&#10;        data.update(self.ncbi_card.get_values())&#10;        return data&#10;&#10;    # -------------------------&#10;    # Public config API&#10;    # -------------------------&#10;    def load_config(self):&#10;        merged = self._load_config_merged()&#10;        self._apply_config_to_components(merged)&#10;&#10;    def save_config(self):&#10;        data = self._collect_components_config()&#10;        self._write_config_file(data)&#10;&#10;        # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;        for key in DEFAULT_CONFIG:&#10;            if key in data:&#10;                DEFAULT_CONFIG[key] = data[key]&#10;&#10;        # 旧行为：保存成功在 SSH 卡片区域提示&#10;        try:&#10;            self.ssh_card.status_label.setText(&quot;设置已保存&quot;)&#10;        except Exception:&#10;            pass&#10;&#10;        # 保存后锁定 NCBI（有 key 就锁定，空就保持可编辑）&#10;        self.ncbi_card.lock_if_needed()&#10;&#10;    def _save_ncbi_config(self):&#10;        data = self._read_config_file()&#10;        data[&quot;ncbi_api_key&quot;] = self.ncbi_card.get_values().get(&quot;ncbi_api_key&quot;, &quot;&quot;)&#10;        self._write_config_file(data)&#10;        # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;        DEFAULT_CONFIG[&quot;ncbi_api_key&quot;] = data[&quot;ncbi_api_key&quot;]&#10;        self.ncbi_card.lock_if_needed()&#10;&#10;    # 在 SettingsPage 类中添加这个方法处理联动&#10;    def _on_ssh_state_changed(self, connected: bool):&#10;        &quot;&quot;&quot;当 SSH 连接状态变化时，通知 Linux 卡片&quot;&quot;&quot;&#10;        client = self.ssh_card.get_active_client() if connected else None&#10;        self.linux_card.set_active_client(client)&#10;" />
              <option name="updatedContent" value="import json&#10;import os&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtWidgets import QLabel, QPushButton&#10;&#10;from config import DEFAULT_CONFIG&#10;from ui.page_base import BasePage&#10;from ui.widgets import SshSettingsCard, NcbiSettingsCard, BlastSettingsCard, LinuxSettingsCard&#10;from ui.widgets.styles import PAGE_HEADER_TITLE, BUTTON_SUCCESS, COLOR_BG_APP&#10;&#10;class SettingsPage(BasePage):&#10;    def __init__(self):&#10;        super().__init__(&quot;\u2699 \u8bbe\u7f6e&quot;)&#10;        if hasattr(self, &quot;label&quot;):&#10;            self.label.hide()&#10;&#10;        self.config_dir = os.path.join(os.getenv('APPDATA'), &quot;H2OMeta&quot;)&#10;        self.config_path = os.path.join(self.config_dir, &quot;config.json&quot;)&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;&#10;        self.setStyleSheet(f&quot;background-color: {COLOR_BG_APP};&quot;)&#10;&#10;        self.init_ui()&#10;        self.load_config()&#10;&#10;        # 启动即自动执行一次连接测试&#10;        QTimer.singleShot(1000, self.ssh_card.auto_check_on_start)&#10;&#10;    # -------------------------&#10;    # UI 构建：调度员&#10;    # -------------------------&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;调度员：只负责页面整体参数与模块调用顺序，不写任何卡片细节。&quot;&quot;&quot;&#10;        self.layout.setContentsMargins(40, 30, 40, 30)&#10;        self.layout.setSpacing(25)&#10;&#10;        self._init_header()&#10;        self._init_cards()&#10;        self._init_save_area()&#10;&#10;        self.layout.addStretch()&#10;&#10;    def _init_header(self):&#10;        header_title = QLabel(&quot;系统设置&quot;)&#10;        header_title.setStyleSheet(PAGE_HEADER_TITLE)&#10;        self.layout.addWidget(header_title)&#10;&#10;    def _init_cards(self):&#10;        # SSH 卡片&#10;        self.ssh_card = SshSettingsCard()&#10;        self.layout.addWidget(self.ssh_card)&#10;&#10;         # Linux 设置卡片&#10;        self.linux_card = LinuxSettingsCard()&#10;        self.layout.addWidget(self.linux_card)&#10;&#10;        # BLAST 数据库设置卡片 (新增)&#10;        # 传入 ssh_card 的 get_active_client 方法，以便它可以调用 SSH 进行验证&#10;        self.blast_card = BlastSettingsCard(self.ssh_card.get_active_client)&#10;        self.blast_card.request_save.connect(self.save_config)  # 连接保存信号&#10;        self.layout.addWidget(self.blast_card)&#10;&#10;        # NCBI 卡片&#10;        self.ncbi_card = NcbiSettingsCard()&#10;        self.ncbi_card.request_save.connect(self._save_ncbi_config)&#10;        self.layout.addWidget(self.ncbi_card)&#10;&#10;        # --- 核心联动：SSH 连接成功后，自动把 Client 传给 Linux 卡片 ---&#10;        self.ssh_card.connection_state_changed.connect(self._on_ssh_state_changed)&#10;       &#10;&#10;    def _init_save_area(self):&#10;        # 移除单独的保存按钮，因为现在保存功能集成在BLAST设置卡片中&#10;        pass&#10;&#10;    # -------------------------&#10;    # 对外能力：提供共享 SSHClient&#10;    # -------------------------&#10;    def get_active_client(self):&#10;        return self.ssh_card.get_active_client()&#10;&#10;    def set_global_lock(self, locked: bool, reason: str = &quot;SSH 正在使用中，系统设置已锁定&quot;) -&gt; None:&#10;        self.ssh_card.set_external_lock(locked, reason)&#10;        self.blast_card.set_external_lock(locked)&#10;        if hasattr(self.linux_card, &quot;_toggle_lock&quot;):&#10;            self.linux_card._toggle_lock(locked)&#10;        self.ncbi_card.set_external_lock(locked)&#10;&#10;    # -------------------------&#10;    # Config IO：标准化读写 + 组件同步&#10;    # -------------------------&#10;    def _read_config_file(self) -&gt; dict:&#10;        if not os.path.exists(self.config_path):&#10;            return {}&#10;        try:&#10;            with open(self.config_path, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;            return data if isinstance(data, dict) else {}&#10;        except Exception:&#10;            return {}&#10;&#10;    def _write_config_file(self, data: dict) -&gt; None:&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;        with open(self.config_path, 'w', encoding='utf-8') as f:&#10;            json.dump(data, f, ensure_ascii=False, indent=2)&#10;&#10;    def _default_config_for_ui(self) -&gt; dict:&#10;        &quot;&quot;&quot;补充默认配置项&quot;&quot;&quot;&#10;        return {&#10;            &quot;server_ip&quot;: DEFAULT_CONFIG.get(&quot;ip&quot;, &quot;&quot;),&#10;            &quot;ssh_user&quot;: DEFAULT_CONFIG.get(&quot;user&quot;, &quot;&quot;),&#10;            &quot;ssh_pwd&quot;: DEFAULT_CONFIG.get(&quot;pwd&quot;, &quot;&quot;),&#10;            &quot;ncbi_api_key&quot;: DEFAULT_CONFIG.get(&quot;ncbi_api_key&quot;, &quot;&quot;),&#10;            &quot;remote_db&quot;: DEFAULT_CONFIG.get(&quot;remote_db&quot;, &quot;&quot;), # 新增项&#10;            &quot;blast_bin&quot;: DEFAULT_CONFIG.get(&quot;blast_bin&quot;, &quot;&quot;), # 新增项&#10;            &quot;remote_dir&quot;: DEFAULT_CONFIG.get(&quot;remote_dir&quot;, &quot;&quot;), # 新增&#10;        }&#10;&#10;    def _load_config_merged(self) -&gt; dict:&#10;        merged = self._default_config_for_ui()&#10;        merged.update({k: v for k, v in self._read_config_file().items() if v is not None})&#10;        return merged&#10;&#10;    def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;        &quot;&quot;&quot;将加载的配置分发给各卡片&quot;&quot;&quot;&#10;        self.ssh_card.set_values(&#10;            server_ip=str(merged.get(&quot;server_ip&quot;, &quot;&quot;) or &quot;&quot;),&#10;            ssh_user=str(merged.get(&quot;ssh_user&quot;, &quot;&quot;) or &quot;&quot;),&#10;            ssh_pwd=str(merged.get(&quot;ssh_pwd&quot;, &quot;&quot;) or &quot;&quot;),&#10;        )&#10;        # 为 Linux 卡片设置初始值&#10;        self.linux_card.set_values(&#10;            project_path=str(merged.get(&quot;linux_project_path&quot;, &quot;&quot;) or &quot;&quot;),&#10;            conda_env=str(merged.get(&quot;conda_env_path&quot;, &quot;&quot;) or &quot;&quot;)&#10;        )&#10;        self.blast_card.set_values(&#10;            remote_db=str(merged.get(&quot;remote_db&quot;, &quot;&quot;) or &quot;&quot;),&#10;            blast_bin=str(merged.get(&quot;blast_bin&quot;, &quot;&quot;) or &quot;&quot;),&#10;            remote_dir=str(merged.get(&quot;remote_dir&quot;, &quot;&quot;) or &quot;&quot;)&#10;        )&#10;        self.ncbi_card.set_values(ncbi_api_key=str(merged.get(&quot;ncbi_api_key&quot;, &quot;&quot;) or &quot;&quot;))&#10;&#10;    def _collect_components_config(self) -&gt; dict:&#10;        &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;        data = {}&#10;        data.update(self.ssh_card.get_values())&#10;        data.update(self.blast_card.get_values())  # 收集新卡片数据&#10;        data.update(self.linux_card.get_values())&#10;        data.update(self.ncbi_card.get_values())&#10;        return data&#10;&#10;    # -------------------------&#10;    # Public config API&#10;    # -------------------------&#10;    def load_config(self):&#10;        merged = self._load_config_merged()&#10;        self._apply_config_to_components(merged)&#10;&#10;    def save_config(self):&#10;        try:&#10;            data = self._collect_components_config()&#10;            self._write_config_file(data)&#10;&#10;            # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;            for key in DEFAULT_CONFIG:&#10;                if key in data:&#10;                    DEFAULT_CONFIG[key] = data[key]&#10;&#10;            # 旧行为：保存成功在 SSH 卡片区域提示&#10;            try:&#10;                self.ssh_card.status_label.setText(&quot;设置已保存&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;            # 保存后锁定 NCBI（有 key 就锁定，空就保持可编辑）&#10;            self.ncbi_card.lock_if_needed()&#10;        except Exception as e:&#10;            # 捕获保存过程中的任何异常，防止程序崩溃&#10;            import logging&#10;            logging.error(f&quot;保存配置失败: {e}&quot;, exc_info=True)&#10;            try:&#10;                self.ssh_card.status_label.setText(f&quot;保存失败: {str(e)}&quot;)&#10;                self.ssh_card.status_label.setStyleSheet(&quot;color: #e74c3c;&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;    def _save_ncbi_config(self):&#10;        data = self._read_config_file()&#10;        data[&quot;ncbi_api_key&quot;] = self.ncbi_card.get_values().get(&quot;ncbi_api_key&quot;, &quot;&quot;)&#10;        self._write_config_file(data)&#10;        # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;        DEFAULT_CONFIG[&quot;ncbi_api_key&quot;] = data[&quot;ncbi_api_key&quot;]&#10;        self.ncbi_card.lock_if_needed()&#10;&#10;    # 在 SettingsPage 类中添加这个方法处理联动&#10;    def _on_ssh_state_changed(self, connected: bool):&#10;        &quot;&quot;&quot;当 SSH 连接状态变化时，通知 Linux 卡片&quot;&quot;&quot;&#10;        client = self.ssh_card.get_active_client() if connected else None&#10;        self.linux_card.set_active_client(client)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>