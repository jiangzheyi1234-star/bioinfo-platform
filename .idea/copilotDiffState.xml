<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BLAST_CRASH_FIX.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BLAST_CRASH_FIX.md" />
              <option name="updatedContent" value="# BLAST 设置卡片崩溃问题修复说明&#10;&#10;## 问题描述&#10;&#10;**症状：** 点击 BLAST 环境设置卡片的&quot;验证并保存&quot;按钮后，程序立即崩溃退出  &#10;**退出代码：** -1073740791 (0xC0000409) - 表示严重错误（访问冲突/栈损坏）&#10;&#10;## 根本原因分析&#10;&#10;经过代码审查，发现了以下关键问题：&#10;&#10;### 1. **settings_page.py 中的致命缩进错误**&#10;&#10;**位置：** `ui/pages/settings_page.py` 第 143-150 行&#10;&#10;**问题代码：**&#10;```python&#10;def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;    # ... 其他代码 ...&#10;    self.ncbi_card.set_values(ncbi_api_key=str(merged.get(&quot;ncbi_api_key&quot;, &quot;&quot;) or &quot;&quot;))  &#10;&#10;    def _collect_components_config(self) -&gt; dict:  # ❌ 错误：嵌套在另一个方法内部&#10;         &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;    data = {}&#10;    # ... 其他代码 ...&#10;```&#10;&#10;**后果：**&#10;- `_collect_components_config` 方法被错误地定义在 `_apply_config_to_components` 方法内部&#10;- 当 `save_config()` 方法尝试调用 `self._collect_components_config()` 时找不到该方法&#10;- 导致 `AttributeError` 异常，但由于异常处理不当，程序直接崩溃&#10;&#10;**修复：**&#10;```python&#10;def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;    # ... 其他代码 ...&#10;    self.ncbi_card.set_values(ncbi_api_key=str(merged.get(&quot;ncbi_api_key&quot;, &quot;&quot;) or &quot;&quot;))&#10;&#10;def _collect_components_config(self) -&gt; dict:  # ✅ 正确：作为独立的类方法&#10;    &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;    data = {}&#10;    # ... 其他代码 ...&#10;```&#10;&#10;### 2. **blast_settings_card.py 中的信号重复连接**&#10;&#10;**位置：** `ui/widgets/blast_settings_card.py` 第 365-395 行&#10;&#10;**问题代码：**&#10;```python&#10;def _start_verification(self):&#10;    # ... 其他代码 ...&#10;    &#10;    # 连接信号&#10;    self._thread.started.connect(self._worker.run)&#10;    self._worker.finished.connect(self._on_verify_finished)&#10;&#10;    # 定义清理函数&#10;    def cleanup():&#10;        if hasattr(self, '_thread') and self._thread:&#10;            self._thread.quit()&#10;            self._thread.wait()&#10;            self._thread = None&#10;        # ... 其他代码 ...&#10;&#10;    # ❌ 问题：cleanup 函数也连接到 finished 信号&#10;    self._worker.finished.connect(cleanup)&#10;&#10;    self._thread.start()&#10;&#10;def _on_verify_finished(self, success, message):&#10;    # ... 处理验证结果 ...&#10;    self.request_save.emit()  # 触发保存&#10;    self._refresh_interaction_state()  # ❌ cleanup 会在此之后再次被调用&#10;```&#10;&#10;**后果：**&#10;- `finished` 信号被连接了两次：`_on_verify_finished` 和 `cleanup`&#10;- 验证完成后，两个槽函数都会被调用&#10;- 可能导致资源重复释放或访问已释放的资源&#10;- 在某些情况下造成内存访问冲突&#10;&#10;**修复：**&#10;```python&#10;def _start_verification(self):&#10;    # ... 其他代码 ...&#10;    &#10;    # 连接信号（只连接一次）&#10;    self._thread.started.connect(self._worker.run)&#10;    self._worker.finished.connect(self._on_verify_finished)&#10;    &#10;    # 线程完成后自动清理&#10;    self._thread.finished.connect(self._thread.deleteLater)&#10;&#10;    self._thread.start()&#10;&#10;def _on_verify_finished(self, success, message):&#10;    # ... 处理验证结果 ...&#10;    self.request_save.emit()&#10;    &#10;    # ✅ 正确：在槽函数内部完成清理&#10;    if hasattr(self, '_thread'):&#10;        self._thread.quit()&#10;        self._thread.wait()&#10;    &#10;    if hasattr(self, '_worker'):&#10;        self._worker.deleteLater()&#10;        &#10;    self._refresh_interaction_state()&#10;```&#10;&#10;### 3. **缺少异常处理保护**&#10;&#10;**问题：**&#10;- `save_config()` 方法没有 try-except 保护&#10;- 任何异常都会直接导致程序崩溃&#10;- 用户看不到错误信息&#10;&#10;**修复：**&#10;```python&#10;def save_config(self):&#10;    try:&#10;        data = self._collect_components_config()&#10;        self._write_config_file(data)&#10;        # ... 其他代码 ...&#10;    except Exception as e:&#10;        # 捕获并记录异常，防止崩溃&#10;        logging.error(f&quot;保存配置失败: {e}&quot;, exc_info=True)&#10;        try:&#10;            self.ssh_card.status_label.setText(f&quot;保存失败: {str(e)}&quot;)&#10;            self.ssh_card.status_label.setStyleSheet(&quot;color: #e74c3c;&quot;)&#10;        except Exception:&#10;            pass&#10;```&#10;&#10;## 修复清单&#10;&#10;### ✅ 已修复的文件&#10;&#10;1. **`ui/pages/settings_page.py`**&#10;   - ✅ 修复 `_collect_components_config` 方法的缩进&#10;   - ✅ 添加 `save_config` 方法的异常处理&#10;&#10;2. **`ui/widgets/blast_settings_card.py`**&#10;   - ✅ 移除重复的 cleanup 函数连接&#10;   - ✅ 在 `_on_verify_finished` 中正确清理资源&#10;&#10;3. **`ui/main.py`**&#10;   - ✅ 添加全局异常处理器&#10;   - ✅ 增强日志记录功能&#10;   - ✅ 崩溃时保存详细日志&#10;&#10;## 测试方法&#10;&#10;### 方法 1：使用测试脚本&#10;&#10;运行测试脚本验证修复：&#10;```bash&#10;python test_blast_settings_fix.py&#10;```&#10;&#10;操作步骤：&#10;1. 点击&quot;修改&quot;按钮&#10;2. 填写配置信息&#10;3. 点击&quot;验证并保存&quot;&#10;4. 观察是否正常工作（不应崩溃）&#10;&#10;### 方法 2：在实际应用中测试&#10;&#10;1. 启动应用程序：&#10;```bash&#10;python ui/main.py&#10;```&#10;&#10;2. 进入设置页面&#10;3. 连接 SSH&#10;4. 在 BLAST 设置卡片中：&#10;   - 点击&quot;修改&quot;&#10;   - 填写 BLAST 程序路径和数据库路径&#10;   - 点击&quot;验证并保存&quot;&#10;&#10;**预期结果：**&#10;- 不应崩溃&#10;- 如果验证失败，应显示错误信息&#10;- 如果验证成功，应保存配置并锁定界面&#10;- 日志文件中应有详细记录&#10;&#10;### 检查日志&#10;&#10;查看日志文件确认修复：&#10;```bash&#10;# 查看最新的应用日志&#10;cat logs/app_*.log | tail -50&#10;&#10;# 检查是否有崩溃日志&#10;ls -la logs/crash_*.log&#10;```&#10;&#10;如果修复成功，应该：&#10;- ✅ 不会生成新的 crash 日志&#10;- ✅ app 日志中能看到正常的保存流程&#10;- ✅ 没有 AttributeError 或 访问冲突错误&#10;&#10;## 技术细节&#10;&#10;### 问题 1 的技术解释&#10;&#10;Python 中方法的缩进定义了其作用域：&#10;&#10;```python&#10;class MyClass:&#10;    def method_a(self):&#10;        # method_a 的代码&#10;        &#10;        def method_b(self):  # ❌ 错误：这是嵌套函数，不是类方法&#10;            pass&#10;    &#10;    def method_c(self):  # ✅ 正确：这是类方法&#10;        pass&#10;```&#10;&#10;当 `method_b` 被错误地嵌套在 `method_a` 内部时：&#10;- 它只在 `method_a` 执行期间存在&#10;- 无法通过 `self.method_b()` 调用&#10;- 尝试调用会抛出 `AttributeError`&#10;&#10;### 问题 2 的技术解释&#10;&#10;PyQt6 信号-槽机制：&#10;&#10;```python&#10;# 每次调用 connect，都会添加一个新的连接&#10;signal.connect(slot1)  # 连接 1&#10;signal.connect(slot2)  # 连接 2&#10;&#10;# 当信号触发时，所有连接的槽都会被调用&#10;signal.emit()  # 调用 slot1()，然后调用 slot2()&#10;```&#10;&#10;问题场景：&#10;```python&#10;self._worker.finished.connect(self._on_verify_finished)  # 连接 1&#10;self._worker.finished.connect(cleanup)                   # 连接 2&#10;&#10;# 当验证完成时&#10;# 1. _on_verify_finished() 被调用&#10;#    - 可能触发 request_save 信号&#10;#    - 可能访问 self._thread&#10;# 2. cleanup() 被调用&#10;#    - 释放 self._thread&#10;#    - 如果 _on_verify_finished 还在运行，可能访问已释放的资源&#10;```&#10;&#10;### 退出代码 0xC0000409 的含义&#10;&#10;**0xC0000409 = STATUS_STACK_BUFFER_OVERRUN**&#10;&#10;这是 Windows 系统的安全机制，当检测到以下情况时会强制终止程序：&#10;- 栈缓冲区溢出&#10;- 破坏了栈保护 cookie&#10;- 访问已释放的内存&#10;- 重复释放内存&#10;&#10;在我们的情况下，最可能的原因是：&#10;- cleanup 函数重复释放 thread/worker&#10;- 在资源释放后仍然访问它们&#10;- 信号槽的重复调用导致栈状态异常&#10;&#10;## 预防措施&#10;&#10;为防止类似问题再次发生，建议：&#10;&#10;### 1. 代码规范&#10;- ✅ 使用 IDE 的自动格式化功能（如 Black）&#10;- ✅ 启用代码检查工具（如 Pylint, Flake8）&#10;- ✅ 进行代码审查&#10;&#10;### 2. 测试策略&#10;- ✅ 为关键功能编写单元测试&#10;- ✅ 在修改后进行回归测试&#10;- ✅ 使用调试器逐步执行代码&#10;&#10;### 3. 异常处理&#10;- ✅ 所有公共 API 方法都应有 try-except&#10;- ✅ 记录详细的错误日志&#10;- ✅ 向用户显示友好的错误消息&#10;&#10;### 4. 信号-槽管理&#10;- ✅ 避免重复连接同一个信号&#10;- ✅ 使用 `disconnect()` 清理不需要的连接&#10;- ✅ 在文档中标注信号的生命周期&#10;&#10;### 5. 资源管理&#10;- ✅ 使用 `deleteLater()` 而不是直接删除 Qt 对象&#10;- ✅ 确保 thread 在删除前已经 quit 和 wait&#10;- ✅ 避免在槽函数中删除发射信号的对象&#10;&#10;## 相关文件&#10;&#10;### 修复的核心文件&#10;- `ui/pages/settings_page.py` - 修复缩进错误和添加异常处理&#10;- `ui/widgets/blast_settings_card.py` - 修复信号重复连接&#10;- `ui/main.py` - 添加全局异常处理&#10;&#10;### 测试文件&#10;- `test_blast_settings_fix.py` - 验证修复的测试脚本&#10;&#10;### 日志文件&#10;- `logs/app_*.log` - 应用运行日志&#10;- `logs/crash_*.log` - 崩溃日志（修复后不应再生成）&#10;&#10;## 总结&#10;&#10;此次修复解决了三个严重问题：&#10;1. **方法缩进错误** - 导致方法找不到&#10;2. **信号重复连接** - 导致资源访问冲突&#10;3. **缺少异常处理** - 导致错误直接崩溃&#10;&#10;所有问题都已修复并添加了保护措施。修复后的代码更加健壮，能够优雅地处理错误而不会崩溃。&#10;&#10;---&#10;&#10;**修复完成时间：** 2026-01-18  &#10;**状态：** ✅ 已完成  &#10;**测试状态：** 待用户验证&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_blast_settings_fix.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_blast_settings_fix.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;测试 BLAST 设置卡片的保存功能&#10;验证修复是否有效&#10;&quot;&quot;&quot;&#10;import sys&#10;import os&#10;&#10;# 添加项目根目录到路径&#10;root_dir = os.path.dirname(os.path.abspath(__file__))&#10;if root_dir not in sys.path:&#10;    sys.path.append(root_dir)&#10;&#10;import logging&#10;logging.basicConfig(&#10;    level=logging.DEBUG,&#10;    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'&#10;)&#10;&#10;from PyQt6.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget&#10;from ui.widgets.blast_settings_card import BlastSettingsCard&#10;&#10;class TestWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;BLAST Settings Card 测试&quot;)&#10;        self.setGeometry(100, 100, 800, 600)&#10;        &#10;        # 创建中心部件&#10;        central_widget = QWidget()&#10;        self.setCentralWidget(central_widget)&#10;        &#10;        layout = QVBoxLayout(central_widget)&#10;        &#10;        # 模拟 SSH 客户端函数&#10;        def mock_ssh_client():&#10;            print(&quot;⚠️ 模拟 SSH 客户端 - 返回 None（需要真实 SSH 连接才能测试验证功能）&quot;)&#10;            return None&#10;        &#10;        # 添加 BLAST Settings Card&#10;        self.blast_card = BlastSettingsCard(mock_ssh_client)&#10;        layout.addWidget(self.blast_card)&#10;        &#10;        # 连接保存信号&#10;        self.blast_card.request_save.connect(self.on_save_requested)&#10;        &#10;        layout.addStretch()&#10;        &#10;        print(&quot;=&quot; * 60)&#10;        print(&quot;BLAST Settings Card 测试窗口&quot;)&#10;        print(&quot;=&quot; * 60)&#10;        print(&quot;1. 点击'修改'按钮进入编辑模式&quot;)&#10;        print(&quot;2. 填写配置信息&quot;)&#10;        print(&quot;3. 点击'验证并保存'按钮&quot;)&#10;        print(&quot;4. 观察是否出现崩溃&quot;)&#10;        print()&#10;        print(&quot;修复内容：&quot;)&#10;        print(&quot;- 修复了 settings_page.py 中的缩进错误&quot;)&#10;        print(&quot;- 修复了信号重复连接导致的资源冲突&quot;)&#10;        print(&quot;- 添加了异常处理保护&quot;)&#10;        print(&quot;=&quot; * 60)&#10;    &#10;    def on_save_requested(self):&#10;        print(&quot;✅ 接收到保存信号 - request_save.emit() 成功触发&quot;)&#10;        print(&quot; 模拟保存配置...&quot;)&#10;        &#10;        # 模拟保存逻辑&#10;        try:&#10;            values = self.blast_card.get_values()&#10;            print(f&quot;   - BLAST 程序路径: {values.get('blast_bin', '未设置')}&quot;)&#10;            print(f&quot;   - 远程数据库路径: {values.get('remote_db', '未设置')}&quot;)&#10;            print(f&quot;   - 远程工作目录: {values.get('remote_dir', '未设置')}&quot;)&#10;            print(&quot;✅ 配置保存成功（模拟）&quot;)&#10;        except Exception as e:&#10;            print(f&quot;❌ 保存失败: {e}&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;if __name__ == '__main__':&#10;    print(&quot;\n 启动测试程序...\n&quot;)&#10;    app = QApplication(sys.argv)&#10;    window = TestWindow()&#10;    window.show()&#10;    sys.exit(app.exec())&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/pages/settings_page.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/pages/settings_page.py" />
              <option name="originalContent" value="import json&#10;import os&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtWidgets import QLabel, QPushButton, QScrollArea, QWidget, QVBoxLayout, QFrame&#10;&#10;from config import DEFAULT_CONFIG&#10;from ui.page_base import BasePage&#10;from ui.widgets import SshSettingsCard, NcbiSettingsCard, BlastSettingsCard, LinuxSettingsCard&#10;from ui.widgets.styles import PAGE_HEADER_TITLE, BUTTON_SUCCESS, COLOR_BG_APP, SCROLL_BAR_ELEGANT&#10;&#10;class SettingsPage(BasePage):&#10;    def __init__(self):&#10;        super().__init__(&quot;\u2699 \u8bbe\u7f6e&quot;)&#10;        if hasattr(self, &quot;label&quot;):&#10;            self.label.hide()&#10;&#10;        self.config_dir = os.path.join(os.getenv('APPDATA'), &quot;H2OMeta&quot;)&#10;        self.config_path = os.path.join(self.config_dir, &quot;config.json&quot;)&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;&#10;        self.setStyleSheet(f&quot;background-color: {COLOR_BG_APP};&quot;)&#10;&#10;        self.init_ui()&#10;        self.load_config()&#10;&#10;        # 启动即自动执行一次连接测试&#10;        QTimer.singleShot(1000, self.ssh_card.auto_check_on_start)&#10;&#10;    # -------------------------&#10;    # UI 构建：调度员&#10;    # -------------------------&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;重构调度员：引入滚动机制&quot;&quot;&quot;&#10;        self.layout.setContentsMargins(40, 30, 40, 30)&#10;        self.layout.setSpacing(20)&#10;&#10;        # 1. 初始化页面标题 (保持在滚动区域上方，固定不动)&#10;        self._init_header()&#10;&#10;        # 2. 创建滚动区域&#10;        scroll_area = QScrollArea()&#10;        scroll_area.setWidgetResizable(True) # 关键：让内部组件随滚动区域缩放&#10;        scroll_area.setFrameShape(QFrame.Shape.NoFrame) # 去掉滚动区域边框&#10;        scroll_area.setStyleSheet(&quot;background-color: transparent;&quot;) # 保持透明背景&#10;&#10;        # 应用优雅的滚动条样式&#10;        scroll_area.verticalScrollBar().setStyleSheet(SCROLL_BAR_ELEGANT)&#10;&#10;        # 3. 创建容器 Widget&#10;        self.scroll_content = QWidget()&#10;        self.scroll_content.setStyleSheet(&quot;background-color: transparent;&quot;)&#10;        &#10;        # 4. 创建内部滚动布局&#10;        self.scroll_layout = QVBoxLayout(self.scroll_content)&#10;        self.scroll_layout.setContentsMargins(0, 0, 10, 0) # 留出一点右边距给滚动条&#10;        self.scroll_layout.setSpacing(25) # 卡片间距&#10;&#10;        # 5. 将卡片加入滚动布局&#10;        self._init_cards()&#10;&#10;        # 6. 完成装配&#10;        scroll_area.setWidget(self.scroll_content)&#10;        self.layout.addWidget(scroll_area) # 将滚动区域加入页面主布局&#10;&#10;        self._init_save_area()&#10;&#10;    def _init_header(self):&#10;        header_title = QLabel(&quot;系统设置&quot;)&#10;        header_title.setStyleSheet(PAGE_HEADER_TITLE)&#10;        self.layout.addWidget(header_title)&#10;&#10;    def _init_cards(self):&#10;        # SSH 卡片&#10;        self.ssh_card = SshSettingsCard()&#10;        self.scroll_layout.addWidget(self.ssh_card) # 关键：使用 scroll_layout&#10;&#10;        # Linux 设置卡片 (你新创建的)&#10;        self.linux_card = LinuxSettingsCard()&#10;        self.scroll_layout.addWidget(self.linux_card)&#10;&#10;        # BLAST 数据库设置卡片&#10;        self.blast_card = BlastSettingsCard(self.ssh_card.get_active_client)&#10;        self.blast_card.request_save.connect(self.save_config)&#10;        self.scroll_layout.addWidget(self.blast_card)&#10;&#10;        # NCBI 卡片&#10;        self.ncbi_card = NcbiSettingsCard()&#10;        self.ncbi_card.request_save.connect(self._save_ncbi_config)&#10;        self.scroll_layout.addWidget(self.ncbi_card)&#10;&#10;        # 在滚动布局底部添加弹簧，确保卡片靠上排列&#10;        self.scroll_layout.addStretch()&#10;        &#10;        # 建立 SSH 与 Linux 配置的联动&#10;        self.ssh_card.connection_state_changed.connect(&#10;            lambda connected: self.linux_card.set_active_client(&#10;                self.ssh_card.get_active_client() if connected else None&#10;            )&#10;        )&#10;&#10;    def _init_save_area(self):&#10;        # 移除单独的保存按钮，因为现在保存功能集成在BLAST设置卡片中&#10;        pass&#10;&#10;    # -------------------------&#10;    # 对外能力：提供共享 SSHClient&#10;    # -------------------------&#10;    def get_active_client(self):&#10;        return self.ssh_card.get_active_client()&#10;&#10;    def set_global_lock(self, locked: bool, reason: str = &quot;SSH 正在使用中，系统设置已锁定&quot;) -&gt; None:&#10;        self.ssh_card.set_external_lock(locked, reason)&#10;        self.blast_card.set_external_lock(locked)&#10;        if hasattr(self.linux_card, &quot;_toggle_lock&quot;):&#10;            self.linux_card._toggle_lock(locked)&#10;        self.ncbi_card.set_external_lock(locked)&#10;&#10;    # -------------------------&#10;    # Config IO：标准化读写 + 组件同步&#10;    # -------------------------&#10;    def _read_config_file(self) -&gt; dict:&#10;        if not os.path.exists(self.config_path):&#10;            return {}&#10;        try:&#10;            with open(self.config_path, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;            return data if isinstance(data, dict) else {}&#10;        except Exception:&#10;            return {}&#10;&#10;    def _write_config_file(self, data: dict) -&gt; None:&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;        with open(self.config_path, 'w', encoding='utf-8') as f:&#10;            json.dump(data, f, ensure_ascii=False, indent=2)&#10;&#10;    def _default_config_for_ui(self) -&gt; dict:&#10;        &quot;&quot;&quot;补充默认配置项&quot;&quot;&quot;&#10;        return {&#10;            &quot;server_ip&quot;: DEFAULT_CONFIG.get(&quot;ip&quot;, &quot;&quot;),&#10;            &quot;ssh_user&quot;: DEFAULT_CONFIG.get(&quot;user&quot;, &quot;&quot;),&#10;            &quot;ssh_pwd&quot;: DEFAULT_CONFIG.get(&quot;pwd&quot;, &quot;&quot;),&#10;            &quot;ncbi_api_key&quot;: DEFAULT_CONFIG.get(&quot;ncbi_api_key&quot;, &quot;&quot;),&#10;        def _collect_components_config(self) -&gt; dict:&#10;             &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;            &quot;remote_dir&quot;: DEFAULT_CONFIG.get(&quot;remote_dir&quot;, &quot;&quot;), # 新增&#10;            &quot;linux_project_path&quot;: &quot;&quot;, # 添加 Linux 项目路径&#10;        data.update(self.blast_card.get_values()) # 收集新卡片数据&#10;        }&#10;&#10;    def _load_config_merged(self) -&gt; dict:&#10;        merged = self._default_config_for_ui()&#10;        merged.update({k: v for k, v in self._read_config_file().items() if v is not None})&#10;        return merged&#10;&#10;    def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;        &quot;&quot;&quot;将加载的配置分发给各卡片&quot;&quot;&quot;&#10;        self.ssh_card.set_values(&#10;            server_ip=str(merged.get(&quot;server_ip&quot;, &quot;&quot;) or &quot;&quot;),&#10;            ssh_user=str(merged.get(&quot;ssh_user&quot;, &quot;&quot;) or &quot;&quot;),&#10;        data = self._collect_components_config()&#10;        self._write_config_file(data)&#10;        self.linux_card.set_values(&#10;        # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;        for key in DEFAULT_CONFIG:&#10;            if key in data:&#10;                DEFAULT_CONFIG[key] = data[key]&#10;            remote_db=str(merged.get(&quot;remote_db&quot;, &quot;&quot;) or &quot;&quot;),&#10;        # 旧行为：保存成功在 SSH 卡片区域提示&#10;        try:&#10;            self.ssh_card.status_label.setText(&quot;设置已保存&quot;)&#10;        except Exception:&#10;            pass&#10;    def _collect_components_config(self) -&gt; dict:&#10;        # 保存后锁定 NCBI（有 key 就锁定，空就保持可编辑）&#10;        self.ncbi_card.lock_if_needed()&#10;    def load_config(self):&#10;        merged = self._load_config_merged()&#10;        self._apply_config_to_components(merged)&#10;&#10;    def save_config(self):&#10;        try:&#10;            data = self._collect_components_config()&#10;            self._write_config_file(data)&#10;&#10;            # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;            for key in DEFAULT_CONFIG:&#10;                if key in data:&#10;                    DEFAULT_CONFIG[key] = data[key]&#10;&#10;            # 旧行为：保存成功在 SSH 卡片区域提示&#10;            try:&#10;                self.ssh_card.status_label.setText(&quot;设置已保存&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;            # 保存后锁定 NCBI（有 key 就锁定，空就保持可编辑）&#10;            self.ncbi_card.lock_if_needed()&#10;        except Exception as e:&#10;            # 捕获保存过程中的任何异常，防止程序崩溃&#10;            import logging&#10;            logging.error(f&quot;保存配置失败: {e}&quot;, exc_info=True)&#10;            try:&#10;                self.ssh_card.status_label.setText(f&quot;保存失败: {str(e)}&quot;)&#10;                self.ssh_card.status_label.setStyleSheet(&quot;color: #e74c3c;&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;    def _save_ncbi_config(self):&#10;        data = self._read_config_file()&#10;        data[&quot;ncbi_api_key&quot;] = self.ncbi_card.get_values().get(&quot;ncbi_api_key&quot;, &quot;&quot;)&#10;        self._write_config_file(data)&#10;        # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;        DEFAULT_CONFIG[&quot;ncbi_api_key&quot;] = data[&quot;ncbi_api_key&quot;]&#10;        self.ncbi_card.lock_if_needed()&#10;&#10;    # 在 SettingsPage 类中添加这个方法处理联动&#10;    def _on_ssh_state_changed(self, connected: bool):&#10;        &quot;&quot;&quot;当 SSH 连接状态变化时，通知 Linux 卡片&quot;&quot;&quot;&#10;        client = self.ssh_card.get_active_client() if connected else None&#10;        self.linux_card.set_active_client(client)&#10;" />
              <option name="updatedContent" value="import json&#10;import os&#10;from PyQt6.QtCore import Qt, QTimer&#10;from PyQt6.QtWidgets import QLabel, QPushButton, QScrollArea, QWidget, QVBoxLayout, QFrame&#10;&#10;from config import DEFAULT_CONFIG&#10;from ui.page_base import BasePage&#10;from ui.widgets import SshSettingsCard, NcbiSettingsCard, BlastSettingsCard, LinuxSettingsCard&#10;from ui.widgets.styles import PAGE_HEADER_TITLE, BUTTON_SUCCESS, COLOR_BG_APP, SCROLL_BAR_ELEGANT&#10;&#10;class SettingsPage(BasePage):&#10;    def __init__(self):&#10;        super().__init__(&quot;\u2699 \u8bbe\u7f6e&quot;)&#10;        if hasattr(self, &quot;label&quot;):&#10;            self.label.hide()&#10;&#10;        self.config_dir = os.path.join(os.getenv('APPDATA'), &quot;H2OMeta&quot;)&#10;        self.config_path = os.path.join(self.config_dir, &quot;config.json&quot;)&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;&#10;        self.setStyleSheet(f&quot;background-color: {COLOR_BG_APP};&quot;)&#10;&#10;        self.init_ui()&#10;        self.load_config()&#10;&#10;        # 启动即自动执行一次连接测试&#10;        QTimer.singleShot(1000, self.ssh_card.auto_check_on_start)&#10;&#10;    # -------------------------&#10;    # UI 构建：调度员&#10;    # -------------------------&#10;    def init_ui(self):&#10;        &quot;&quot;&quot;重构调度员：引入滚动机制&quot;&quot;&quot;&#10;        self.layout.setContentsMargins(40, 30, 40, 30)&#10;        self.layout.setSpacing(20)&#10;&#10;        # 1. 初始化页面标题 (保持在滚动区域上方，固定不动)&#10;        self._init_header()&#10;&#10;        # 2. 创建滚动区域&#10;        scroll_area = QScrollArea()&#10;        scroll_area.setWidgetResizable(True) # 关键：让内部组件随滚动区域缩放&#10;        scroll_area.setFrameShape(QFrame.Shape.NoFrame) # 去掉滚动区域边框&#10;        scroll_area.setStyleSheet(&quot;background-color: transparent;&quot;) # 保持透明背景&#10;&#10;        # 应用优雅的滚动条样式&#10;        scroll_area.verticalScrollBar().setStyleSheet(SCROLL_BAR_ELEGANT)&#10;&#10;        # 3. 创建容器 Widget&#10;        self.scroll_content = QWidget()&#10;        self.scroll_content.setStyleSheet(&quot;background-color: transparent;&quot;)&#10;        &#10;        # 4. 创建内部滚动布局&#10;        self.scroll_layout = QVBoxLayout(self.scroll_content)&#10;        self.scroll_layout.setContentsMargins(0, 0, 10, 0) # 留出一点右边距给滚动条&#10;        self.scroll_layout.setSpacing(25) # 卡片间距&#10;&#10;        # 5. 将卡片加入滚动布局&#10;        self._init_cards()&#10;&#10;        # 6. 完成装配&#10;        scroll_area.setWidget(self.scroll_content)&#10;        self.layout.addWidget(scroll_area) # 将滚动区域加入页面主布局&#10;&#10;        self._init_save_area()&#10;&#10;    def _init_header(self):&#10;        header_title = QLabel(&quot;系统设置&quot;)&#10;        header_title.setStyleSheet(PAGE_HEADER_TITLE)&#10;        self.layout.addWidget(header_title)&#10;&#10;    def _init_cards(self):&#10;        # SSH 卡片&#10;        self.ssh_card = SshSettingsCard()&#10;        self.scroll_layout.addWidget(self.ssh_card) # 关键：使用 scroll_layout&#10;&#10;        # Linux 设置卡片 (你新创建的)&#10;        self.linux_card = LinuxSettingsCard()&#10;        self.linux_card.request_save.connect(self.save_config)  # 连接保存信号&#10;        self.scroll_layout.addWidget(self.linux_card)&#10;&#10;        # BLAST 数据库设置卡片&#10;        self.blast_card = BlastSettingsCard(self.ssh_card.get_active_client)&#10;        self.blast_card.request_save.connect(self.save_config)&#10;        self.scroll_layout.addWidget(self.blast_card)&#10;&#10;        # NCBI 卡片&#10;        self.ncbi_card = NcbiSettingsCard()&#10;        self.ncbi_card.request_save.connect(self._save_ncbi_config)&#10;        self.scroll_layout.addWidget(self.ncbi_card)&#10;&#10;        # 在滚动布局底部添加弹簧，确保卡片靠上排列&#10;        self.scroll_layout.addStretch()&#10;        &#10;        # 建立 SSH 与 Linux 配置的联动&#10;        self.ssh_card.connection_state_changed.connect(&#10;            lambda connected: self.linux_card.set_active_client(&#10;                self.ssh_card.get_active_client() if connected else None&#10;            )&#10;        )&#10;&#10;    def _init_save_area(self):&#10;        # 移除单独的保存按钮，因为现在保存功能集成在BLAST设置卡片中&#10;        pass&#10;&#10;    # -------------------------&#10;    # 对外能力：提供共享 SSHClient&#10;    # -------------------------&#10;    def get_active_client(self):&#10;        return self.ssh_card.get_active_client()&#10;&#10;    def set_global_lock(self, locked: bool, reason: str = &quot;SSH 正在使用中，系统设置已锁定&quot;) -&gt; None:&#10;        self.ssh_card.set_external_lock(locked, reason)&#10;        self.blast_card.set_external_lock(locked)&#10;        if hasattr(self.linux_card, &quot;_toggle_lock&quot;):&#10;            self.linux_card._toggle_lock(locked)&#10;        self.ncbi_card.set_external_lock(locked)&#10;&#10;    # -------------------------&#10;    # Config IO：标准化读写 + 组件同步&#10;    # -------------------------&#10;    def _read_config_file(self) -&gt; dict:&#10;        if not os.path.exists(self.config_path):&#10;            return {}&#10;        try:&#10;            with open(self.config_path, 'r', encoding='utf-8') as f:&#10;                data = json.load(f)&#10;            return data if isinstance(data, dict) else {}&#10;        except Exception:&#10;            return {}&#10;&#10;    def _write_config_file(self, data: dict) -&gt; None:&#10;        os.makedirs(self.config_dir, exist_ok=True)&#10;        with open(self.config_path, 'w', encoding='utf-8') as f:&#10;            json.dump(data, f, ensure_ascii=False, indent=2)&#10;&#10;    def _default_config_for_ui(self) -&gt; dict:&#10;        &quot;&quot;&quot;补充默认配置项&quot;&quot;&quot;&#10;        return {&#10;            &quot;server_ip&quot;: DEFAULT_CONFIG.get(&quot;ip&quot;, &quot;&quot;),&#10;            &quot;ssh_user&quot;: DEFAULT_CONFIG.get(&quot;user&quot;, &quot;&quot;),&#10;            &quot;ssh_pwd&quot;: DEFAULT_CONFIG.get(&quot;pwd&quot;, &quot;&quot;),&#10;            &quot;ncbi_api_key&quot;: DEFAULT_CONFIG.get(&quot;ncbi_api_key&quot;, &quot;&quot;),&#10;            &quot;remote_db&quot;: DEFAULT_CONFIG.get(&quot;remote_db&quot;, &quot;&quot;), # 新增项&#10;            &quot;blast_bin&quot;: DEFAULT_CONFIG.get(&quot;blast_bin&quot;, &quot;&quot;), # 新增项&#10;            &quot;remote_dir&quot;: DEFAULT_CONFIG.get(&quot;remote_dir&quot;, &quot;&quot;), # 新增&#10;            &quot;linux_project_path&quot;: &quot;&quot;, # 添加 Linux 项目路径&#10;            &quot;conda_env_path&quot;: &quot;&quot;, # 添加 Conda 环境路径&#10;            &quot;conda_env_name&quot;: &quot;&quot;, # 添加 Conda 环境显示名称&#10;        }&#10;&#10;    def _load_config_merged(self) -&gt; dict:&#10;        merged = self._default_config_for_ui()&#10;        merged.update({k: v for k, v in self._read_config_file().items() if v is not None})&#10;        return merged&#10;&#10;    def _apply_config_to_components(self, merged: dict) -&gt; None:&#10;        &quot;&quot;&quot;将加载的配置分发给各卡片&quot;&quot;&quot;&#10;        self.ssh_card.set_values(&#10;            server_ip=str(merged.get(&quot;server_ip&quot;, &quot;&quot;) or &quot;&quot;),&#10;            ssh_user=str(merged.get(&quot;ssh_user&quot;, &quot;&quot;) or &quot;&quot;),&#10;            ssh_pwd=str(merged.get(&quot;ssh_pwd&quot;, &quot;&quot;) or &quot;&quot;),&#10;        )&#10;        # 为 Linux 卡片设置初始值&#10;        self.linux_card.set_values(&#10;            project_path=str(merged.get(&quot;linux_project_path&quot;, &quot;&quot;) or &quot;&quot;),&#10;            conda_env=str(merged.get(&quot;conda_env_path&quot;, &quot;&quot;) or &quot;&quot;),&#10;            conda_env_name=str(merged.get(&quot;conda_env_name&quot;, &quot;&quot;) or &quot;&quot;)&#10;        )&#10;        self.blast_card.set_values(&#10;            remote_db=str(merged.get(&quot;remote_db&quot;, &quot;&quot;) or &quot;&quot;),&#10;            blast_bin=str(merged.get(&quot;blast_bin&quot;, &quot;&quot;) or &quot;&quot;),&#10;            remote_dir=str(merged.get(&quot;remote_dir&quot;, &quot;&quot;) or &quot;&quot;)&#10;        )&#10;        self.ncbi_card.set_values(ncbi_api_key=str(merged.get(&quot;ncbi_api_key&quot;, &quot;&quot;) or &quot;&quot;))&#10;&#10;    def _collect_components_config(self) -&gt; dict:&#10;        &quot;&quot;&quot;收集所有卡片的配置&quot;&quot;&quot;&#10;        data = {}&#10;        data.update(self.ssh_card.get_values())&#10;        data.update(self.blast_card.get_values())  # 收集新卡片数据&#10;        data.update(self.linux_card.get_values())&#10;        data.update(self.ncbi_card.get_values())&#10;        return data&#10;&#10;    # -------------------------&#10;    # Public config API&#10;    # -------------------------&#10;    def load_config(self):&#10;        merged = self._load_config_merged()&#10;        self._apply_config_to_components(merged)&#10;&#10;    def save_config(self):&#10;        try:&#10;            data = self._collect_components_config()&#10;            self._write_config_file(data)&#10;&#10;            # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;            for key in DEFAULT_CONFIG:&#10;                if key in data:&#10;                    DEFAULT_CONFIG[key] = data[key]&#10;&#10;            # 旧行为：保存成功在 SSH 卡片区域提示&#10;            try:&#10;                self.ssh_card.status_label.setText(&quot;设置已保存&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;            # 保存后锁定 NCBI（有 key 就锁定，空就保持可编辑）&#10;            self.ncbi_card.lock_if_needed()&#10;        except Exception as e:&#10;            # 捕获保存过程中的任何异常，防止程序崩溃&#10;            import logging&#10;            logging.error(f&quot;保存配置失败: {e}&quot;, exc_info=True)&#10;            try:&#10;                self.ssh_card.status_label.setText(f&quot;保存失败: {str(e)}&quot;)&#10;                self.ssh_card.status_label.setStyleSheet(&quot;color: #e74c3c;&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;    def _save_ncbi_config(self):&#10;        data = self._read_config_file()&#10;        data[&quot;ncbi_api_key&quot;] = self.ncbi_card.get_values().get(&quot;ncbi_api_key&quot;, &quot;&quot;)&#10;        self._write_config_file(data)&#10;        # 同步更新DEFAULT_CONFIG以确保其他页面能获取到最新的配置&#10;        DEFAULT_CONFIG[&quot;ncbi_api_key&quot;] = data[&quot;ncbi_api_key&quot;]&#10;        self.ncbi_card.lock_if_needed()&#10;&#10;    # 在 SettingsPage 类中添加这个方法处理联动&#10;    def _on_ssh_state_changed(self, connected: bool):&#10;        &quot;&quot;&quot;当 SSH 连接状态变化时，通知 Linux 卡片&quot;&quot;&quot;&#10;        client = self.ssh_card.get_active_client() if connected else None&#10;        self.linux_card.set_active_client(client)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ui/widgets/linux_settings_card.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ui/widgets/linux_settings_card.py" />
              <option name="originalContent" value="from __future__ import annotations&#10;&#10;import json&#10;import logging&#10;from typing import Optional&#10;&#10;from PyQt6.QtCore import Qt, pyqtSignal, QThread, QObject, pyqtSlot, QTimer&#10;from PyQt6.QtWidgets import (&#10;    QComboBox,&#10;    QFormLayout,&#10;    QFrame,&#10;    QHBoxLayout,&#10;    QLabel,&#10;    QLineEdit,&#10;    QPushButton,&#10;    QVBoxLayout,&#10;    QWidget,&#10;)&#10;&#10;from ui.widgets.styles import (&#10;    CARD_FRAME,&#10;    INPUT_LINEEDIT,&#10;    INPUT_COMBOBOX,&#10;    BUTTON_PRIMARY,&#10;    CARD_TITLE,&#10;    STATUS_NEUTRAL,&#10;    STATUS_SUCCESS,&#10;    STATUS_ERROR,&#10;    BUTTON_LINK,&#10;)&#10;&#10;&#10;class ClickableHeader(QFrame):&#10;    clicked = pyqtSignal()&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;        self.setCursor(Qt.CursorShape.PointingHandCursor)&#10;&#10;    def mouseReleaseEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.clicked.emit()&#10;        super().mouseReleaseEvent(event)&#10;&#10;&#10;class EnvFetchWorker(QObject):&#10;    finished = pyqtSignal(bool, list, str)  # 成功标志, 环境列表, 错误信息&#10;&#10;    def __init__(self, client):&#10;        super().__init__()&#10;        self.client = client&#10;&#10;    @pyqtSlot()&#10;    def run(self):&#10;        try:&#10;            # 记录开始&#10;            logging.info(&quot;开始获取远程 conda 环境列表&quot;)&#10;            &#10;            # 尝试多个可能的 conda 路径&#10;            commands = [&#10;                &quot;conda env list --json&quot;,&#10;                &quot;source ~/.bashrc &amp;&amp; conda env list --json&quot;,&#10;                &quot;/opt/anaconda3/bin/conda env list --json&quot;,&#10;                &quot;~/anaconda3/bin/conda env list --json&quot;,&#10;                &quot;~/miniconda3/bin/conda env list --json&quot;&#10;            ]&#10;&#10;            output = &quot;&quot;&#10;            error = &quot;&quot;&#10;            &#10;            for cmd in commands:&#10;                logging.debug(f&quot;尝试命令: {cmd}&quot;)&#10;                try:&#10;                    stdin, stdout, stderr = self.client.exec_command(cmd, timeout=10)&#10;                    output = stdout.read().decode('utf-8', errors='ignore').strip()&#10;                    error = stderr.read().decode('utf-8', errors='ignore').strip()&#10;                    &#10;                    logging.debug(f&quot;输出长度: {len(output)}, 错误长度: {len(error)}&quot;)&#10;                    &#10;                    if output:&#10;                        # 查找 JSON 起始位置，忽略可能的 shell 输出&#10;                        json_start = output.find('{')&#10;                        if json_start &gt;= 0:&#10;                            output = output[json_start:]&#10;                            &#10;                            data = json.loads(output)&#10;                            envs = data.get('envs', [])&#10;                            &#10;                            logging.info(f&quot;成功解析，找到 {len(envs)} 个环境&quot;)&#10;                            self.finished.emit(True, envs, &quot;&quot;)&#10;                            return&#10;                &#10;                except json.JSONDecodeError as je:&#10;                    logging.warning(f&quot;JSON 解析失败，尝试下一个命令: {je}&quot;)&#10;                    continue&#10;                except Exception as e:&#10;                    logging.debug(f&quot;命令 '{cmd}' 执行失败: {e}&quot;)&#10;                    continue&#10;            &#10;            # 如果所有命令都失败&#10;            if not output and error:&#10;                logging.error(f&quot;所有命令都失败，最终错误: {error}&quot;)&#10;                self.finished.emit(False, [], error)&#10;            else:&#10;                # 成功执行但没有环境&#10;                logging.info(&quot;命令执行成功但未找到任何环境&quot;)&#10;                self.finished.emit(True, [], &quot;&quot;)  # 成功但无环境&#10;&#10;        except Exception as e:&#10;            logging.error(f&quot;获取环境列表时发生异常: {str(e)}&quot;)&#10;            self.finished.emit(False, [], str(e))&#10;&#10;&#10;class LinuxSettingsCard(QFrame):&#10;    &quot;&quot;&quot;Linux 项目与运行环境配置卡片。&#10;    &#10;    功能：&#10;      - 配置远程 Linux 项目的根路径。&#10;      - 自动拉取并选择远程 Conda 环境。&#10;      - 生成并同步 config.env 配置文件到服务器。&#10;    &quot;&quot;&quot;&#10;&#10;    request_save = pyqtSignal()&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;        self.setObjectName(&quot;LinuxSettingsCard&quot;)&#10;        &#10;        self.active_client = None  # 存储由外部（如 SettingsPage）传入的 SSHClient&#10;        self._is_locked = False&#10;        self._fetching = False  # 添加标志来跟踪是否正在获取环境&#10;        self._in_edit_mode = False  # 添加编辑模式标志&#10;        self._external_lock = False  # 添加外部锁定标志&#10;&#10;        # 自动折叠定时器&#10;        self._auto_fold_timer = QTimer(self)&#10;        self._auto_fold_timer.setSingleShot(True)&#10;        self._auto_fold_timer.timeout.connect(self._auto_fold)&#10;&#10;        self._build_ui()&#10;        self._lock_inputs()  # 默认锁定状态&#10;&#10;    def _build_ui(self) -&gt; None:&#10;        self.setStyleSheet(CARD_FRAME(&quot;LinuxSettingsCard&quot;))&#10;&#10;        main_layout = QVBoxLayout(self)&#10;        main_layout.setContentsMargins(0, 0, 0, 0)&#10;        main_layout.setSpacing(0)&#10;&#10;        # 头部区域 (可点击折叠/展开)&#10;        self.header_area = ClickableHeader()&#10;        self.header_area.setStyleSheet(&quot;background: transparent; border: none;&quot;)&#10;        self.header_area.clicked.connect(self._toggle_container)&#10;&#10;        header_layout = QHBoxLayout(self.header_area)&#10;        header_layout.setContentsMargins(20, 15, 20, 15)&#10;&#10;        self.title_label = QLabel(&quot;Linux 端运行环境配置&quot;)&#10;        self.title_label.setStyleSheet(CARD_TITLE)&#10;&#10;        self.modify_btn = QPushButton(&quot;修改&quot;)&#10;        self.modify_btn.setFixedWidth(60)&#10;        self.modify_btn.setStyleSheet(BUTTON_LINK)&#10;        self.modify_btn.clicked.connect(self._enable_editing)&#10;&#10;        self.arrow_label = QLabel(&quot;▲&quot;)&#10;        self.arrow_label.setStyleSheet(&quot;color: #90adca; font-size: 12px;&quot;)&#10;&#10;        header_layout.addWidget(self.title_label)&#10;        header_layout.addStretch()&#10;        header_layout.addWidget(self.modify_btn)&#10;        header_layout.addWidget(self.arrow_label)&#10;        main_layout.addWidget(self.header_area)&#10;&#10;        # 容器布局&#10;        self.container = QWidget()&#10;        self.container.setStyleSheet(&quot;background: transparent;&quot;)&#10;        c_layout = QVBoxLayout(self.container)&#10;        c_layout.setContentsMargins(20, 0, 20, 20)&#10;&#10;        # 表单布局&#10;        form = QFormLayout()&#10;        form.setVerticalSpacing(15)&#10;&#10;        # 1. Linux 项目根路径&#10;        self.linux_project_path = QLineEdit()&#10;        self.linux_project_path.setStyleSheet(INPUT_LINEEDIT)&#10;        self.linux_project_path.setPlaceholderText(&quot;例如: /home/zyserver/bioinfo-platform&quot;)&#10;&#10;        # 2. Conda 环境下拉框&#10;        self.conda_combo = QComboBox()&#10;        self.conda_combo.setPlaceholderText(&quot;请先连接服务器并获取列表...&quot;)&#10;        self.conda_combo.setEnabled(False)&#10;        # 使用 styles.py 中定义的 INPUT_COMBOBOX 样式&#10;        self.conda_combo.setStyleSheet(INPUT_COMBOBOX)&#10;&#10;        form.addRow(&quot;项目根路径&quot;, self.linux_project_path)&#10;        form.addRow(&quot;Conda 环境&quot;, self.conda_combo)&#10;        c_layout.addLayout(form)&#10;&#10;        # 按钮与状态行&#10;        row = QHBoxLayout()&#10;        self.fetch_btn = QPushButton(&quot;获取远程环境&quot;)&#10;        self.fetch_btn.setFixedWidth(110)&#10;        self.fetch_btn.setStyleSheet(BUTTON_PRIMARY)&#10;        self.fetch_btn.setEnabled(False)&#10;        self.fetch_btn.clicked.connect(self._on_fetch_envs)&#10;&#10;        self.lock_btn = QPushButton(&quot;确认并锁定&quot;)&#10;        self.lock_btn.setFixedWidth(110)&#10;        self.lock_btn.setStyleSheet(BUTTON_PRIMARY)&#10;        self.lock_btn.clicked.connect(self._on_save_and_lock)&#10;&#10;        self.status_label = QLabel(&quot;等待 SSH 连接&quot;)&#10;        self.status_label.setStyleSheet(STATUS_NEUTRAL)&#10;&#10;        row.addWidget(self.fetch_btn)&#10;        row.addWidget(self.lock_btn)&#10;        row.addWidget(self.status_label)&#10;        row.addStretch()&#10;        c_layout.addLayout(row)&#10;&#10;        main_layout.addWidget(self.container)&#10;&#10;    def set_active_client(self, client) -&gt; None:&#10;        &quot;&quot;&quot;接收外部传入的 SSH 客户端实例。&quot;&quot;&quot;&#10;        self.active_client = client&#10;        connected = client is not None&#10;        &#10;        self.fetch_btn.setEnabled(connected and not self._is_locked)&#10;        self.lock_btn.setEnabled(connected)&#10;        &#10;        if connected:&#10;            self.status_label.setText(&quot;SSH 已就绪&quot;)&#10;            self.status_label.setStyleSheet(STATUS_SUCCESS)&#10;        else:&#10;            self.status_label.setText(&quot;等待 SSH 连接&quot;)&#10;            self.status_label.setStyleSheet(STATUS_NEUTRAL)&#10;            self.conda_combo.clear()&#10;            self.conda_combo.setEnabled(False)&#10;&#10;    def _on_fetch_envs(self) -&gt; None:&#10;        &quot;&quot;&quot;执行远程命令获取 Conda 环境列表。&quot;&quot;&quot;&#10;        if not self.active_client or self._fetching or self._external_lock:&#10;            return&#10;&#10;        # 首先更新UI状态&#10;        self.status_label.setText(&quot;正在同步环境 (后台运行)...&quot;)&#10;        self.fetch_btn.setEnabled(False)&#10;        self._fetching = True&#10;&#10;        # 确保之前的线程已经完全清理&#10;        if hasattr(self, '_thread') and self._thread:&#10;            if self._thread.isRunning():&#10;                self._thread.quit()&#10;                self._thread.wait(3000)  # 等待最多3秒&#10;            self._thread.deleteLater()&#10;        &#10;        if hasattr(self, '_worker') and self._worker:&#10;            self._worker.deleteLater()&#10;&#10;        # 创建新线程和worker&#10;        self._thread = QThread()&#10;        self._worker = EnvFetchWorker(self.active_client)&#10;        self._worker.moveToThread(self._thread)&#10;&#10;        # 信号绑定 - 在启动前连接&#10;        self._thread.started.connect(self._worker.run)&#10;        &#10;        # 断开之前的信号连接（如果存在），然后连接新的信号&#10;        try:&#10;            self._worker.finished.disconnect()&#10;        except:&#10;            pass  # 如果没有连接的信号，则忽略异常&#10;        &#10;        self._worker.finished.connect(self._on_fetch_finished)&#10;        self._worker.finished.connect(self._cleanup_fetch_resources)&#10;&#10;        # 启动线程&#10;        self._thread.start()&#10;&#10;    def _cleanup_fetch_resources(self):&#10;        &quot;&quot;&quot;独立的资源清理方法&quot;&quot;&quot;&#10;        # 从主线程中清理资源&#10;        if hasattr(self, '_thread') and self._thread:&#10;            if self._thread.isRunning():&#10;                self._thread.quit()&#10;                self._thread.wait(5000)  # 等待最多5秒&#10;            self._thread.deleteLater()&#10;            try:&#10;                delattr(self, '_thread')&#10;            except AttributeError:&#10;                pass  # 如果属性已被删除，则忽略&#10;            &#10;        if hasattr(self, '_worker') and self._worker:&#10;            self._worker.deleteLater()&#10;            try:&#10;                delattr(self, '_worker')&#10;            except AttributeError:&#10;                pass  # 如果属性已被删除，则忽略&#10;&#10;    def _on_fetch_finished(self, success, envs, error_msg):&#10;        &quot;&quot;&quot;线程结束后的回调&quot;&quot;&quot;&#10;        # 确保在主线程中执行，避免竞态条件&#10;        if hasattr(self, '_fetching') and self._fetching:&#10;            self._fetching = False&#10;            self.fetch_btn.setEnabled(True)&#10;&#10;        if success:&#10;            self.conda_combo.clear()&#10;            for path in envs:&#10;                name = path.split('/')[-1] if '/' in path else path&#10;                self.conda_combo.addItem(name, path)&#10;            self.conda_combo.setEnabled(True)&#10;            self.status_label.setText(f&quot;成功获取 {len(envs)} 个环境&quot;)&#10;            self.status_label.setStyleSheet(STATUS_SUCCESS)&#10;        else:&#10;            self.status_label.setText(f&quot;获取失败: {error_msg[:20]}...&quot;)&#10;            self.status_label.setStyleSheet(STATUS_ERROR)&#10;&#10;    def _on_save_and_lock(self) -&gt; None:&#10;        &quot;&quot;&quot;生成远程 config.env 并切换锁定状态。&quot;&quot;&quot;&#10;        if self._is_locked:&#10;            # 解锁逻辑&#10;            self._is_locked = False&#10;            self.linux_project_path.setEnabled(True)&#10;            self.conda_combo.setEnabled(True)&#10;            self.fetch_btn.setEnabled(True)&#10;            self.lock_btn.setText(&quot;确认并锁定&quot;)&#10;            self.status_label.setText(&quot;配置已解锁&quot;)&#10;            return&#10;&#10;        # 锁定逻辑&#10;        project_path = self.linux_project_path.text().strip()&#10;        env_path = self.conda_combo.currentData()&#10;&#10;        if not project_path or not env_path:&#10;            self.status_label.setText(&quot;请填写路径并选择环境&quot;)&#10;            self.status_label.setStyleSheet(STATUS_ERROR)&#10;            return&#10;&#10;        try:&#10;            # 远程写入配置&#10;            config_content = f&quot;CONDA_ENV_PATH={env_path}\\nPROJECT_ROOT={project_path}&quot;&#10;            # 创建 config 目录并写入 config.env&#10;            cmd = f&quot;mkdir -p {project_path}/config &amp;&amp; echo -e '{config_content}' &gt; {project_path}/config/config.env&quot;&#10;            self.active_client.exec_command(cmd)&#10;&#10;            self._is_locked = True&#10;            self.linux_project_path.setEnabled(False)&#10;            self.conda_combo.setEnabled(False)&#10;            self.fetch_btn.setEnabled(False)&#10;            self.lock_btn.setText(&quot;修改配置&quot;)&#10;            &#10;            self.status_label.setText(&quot;远程配置已生成并锁定&quot;)&#10;            self.status_label.setStyleSheet(STATUS_SUCCESS)&#10;            self.request_save.emit()&#10;        except Exception as e:&#10;            self.status_label.setText(f&quot;保存失败: {str(e)}&quot;)&#10;            self.status_label.setStyleSheet(STATUS_ERROR)&#10;&#10;    def get_values(self) -&gt; dict:&#10;        &quot;&quot;&quot;供 SettingsPage 获取数据。&quot;&quot;&quot;&#10;        return {&#10;            &quot;linux_project_path&quot;: self.linux_project_path.text().strip(),&#10;            &quot;conda_env_path&quot;: self.conda_combo.currentData() or &quot;&quot;,&#10;            &quot;is_locked&quot;: self._is_locked&#10;        }&#10;&#10;    def set_values(self, project_path: str = &quot;&quot;, conda_env: str = &quot;&quot;) -&gt; None:&#10;        &quot;&quot;&quot;供 SettingsPage 回填数据。&quot;&quot;&quot;&#10;        self.linux_project_path.setText(project_path)&#10;        # Conda 环境由于涉及远程获取，通常在连接后由用户选择或自动匹配&#10;&#10;    def _toggle_container(self):&#10;        &quot;&quot;&quot;折叠/展开&quot;&quot;&quot;&#10;        if self._fetching or self._external_lock:&#10;            return&#10;        visible = self.container.isVisible()&#10;        self.container.setVisible(not visible)&#10;        self.arrow_label.setText(&quot;▲&quot; if not visible else &quot;▼&quot;)&#10;&#10;    def _auto_fold(self):&#10;        &quot;&quot;&quot;自动折叠，仅在锁定且可见时触发&quot;&quot;&quot;&#10;        if not self._in_edit_mode and self.container.isVisible():&#10;            self.container.hide()&#10;            self.arrow_label.setText(&quot;▼&quot;)&#10;&#10;    def _enable_editing(self):&#10;        &quot;&quot;&quot;进入编辑模式：解锁输入框，修改按钮保持可见，显示保存按钮&quot;&quot;&quot;&#10;        if self._external_lock:&#10;            return&#10;        self.container.show()&#10;        self.arrow_label.setText(&quot;▲&quot;)&#10;&#10;        self.linux_project_path.setEnabled(True)&#10;        self.conda_combo.setEnabled(True)&#10;&#10;        self.lock_btn.show()&#10;        self.lock_btn.setEnabled(True)&#10;        self.modify_btn.show()  # 修改按钮保持可见&#10;&#10;        self.status_label.setText(&quot;请修改配置并保存&quot;)&#10;        self.status_label.setStyleSheet(STATUS_NEUTRAL)&#10;        self._in_edit_mode = True&#10;&#10;    def _lock_inputs(self):&#10;        &quot;&quot;&quot;锁定模式：禁用输入框，修改按钮保持可见&quot;&quot;&quot;&#10;        self.linux_project_path.setEnabled(False)&#10;        self.conda_combo.setEnabled(False)&#10;&#10;        self.lock_btn.setText(&quot;修改配置&quot;)&#10;        self.modify_btn.show()  # 修改按钮始终保持可见&#10;        if self._is_locked:&#10;            self.status_label.setText(&quot;配置已保存&quot;)&#10;        else:&#10;            self.status_label.setText(&quot;等待配置&quot;)&#10;        self._in_edit_mode = False&#10;&#10;    def set_external_lock(self, locked: bool) -&gt; None:&#10;        &quot;&quot;&quot;外部锁定功能，用于在SSH连接被占用时禁用编辑&quot;&quot;&quot;&#10;        if self._external_lock == locked:&#10;            return&#10;        self._external_lock = locked&#10;        self._refresh_interaction_state()&#10;&#10;    def _refresh_interaction_state(self) -&gt; None:&#10;        &quot;&quot;&quot;刷新交互状态，处理外部锁定等情况&quot;&quot;&quot;&#10;        if self._external_lock:&#10;            for w in [self.linux_project_path, self.conda_combo, self.modify_btn, self.lock_btn]:&#10;                w.setEnabled(False)&#10;            return&#10;&#10;        if self._fetching:&#10;            return&#10;&#10;        if self._in_edit_mode:&#10;            self.linux_project_path.setEnabled(True)&#10;            self.conda_combo.setEnabled(True)&#10;            self.lock_btn.setEnabled(True)&#10;            self.modify_btn.setEnabled(True)&#10;        else:&#10;            self.linux_project_path.setEnabled(False)&#10;            self.conda_combo.setEnabled(False)&#10;            self.modify_btn.setEnabled(True)" />
              <option name="updatedContent" value="from __future__ import annotations&#10;&#10;import json&#10;import logging&#10;from typing import Optional&#10;&#10;from PyQt6.QtCore import Qt, pyqtSignal, QThread, QObject, pyqtSlot, QTimer&#10;from PyQt6.QtWidgets import (&#10;    QComboBox,&#10;    QFormLayout,&#10;    QFrame,&#10;    QHBoxLayout,&#10;    QLabel,&#10;    QLineEdit,&#10;    QPushButton,&#10;    QVBoxLayout,&#10;    QWidget,&#10;)&#10;&#10;from ui.widgets.styles import (&#10;    CARD_FRAME,&#10;    INPUT_LINEEDIT,&#10;    INPUT_COMBOBOX,&#10;    BUTTON_PRIMARY,&#10;    CARD_TITLE,&#10;    STATUS_NEUTRAL,&#10;    STATUS_SUCCESS,&#10;    STATUS_ERROR,&#10;    BUTTON_LINK,&#10;)&#10;&#10;&#10;class ClickableHeader(QFrame):&#10;    clicked = pyqtSignal()&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;        self.setCursor(Qt.CursorShape.PointingHandCursor)&#10;&#10;    def mouseReleaseEvent(self, event):&#10;        if event.button() == Qt.MouseButton.LeftButton:&#10;            self.clicked.emit()&#10;        super().mouseReleaseEvent(event)&#10;&#10;&#10;class EnvFetchWorker(QObject):&#10;    finished = pyqtSignal(bool, list, str)  # 成功标志, 环境列表, 错误信息&#10;&#10;    def __init__(self, client):&#10;        super().__init__()&#10;        self.client = client&#10;&#10;    @pyqtSlot()&#10;    def run(self):&#10;        try:&#10;            # 记录开始&#10;            logging.info(&quot;开始获取远程 conda 环境列表&quot;)&#10;            &#10;            # 尝试多个可能的 conda 路径&#10;            commands = [&#10;                &quot;conda env list --json&quot;,&#10;                &quot;source ~/.bashrc &amp;&amp; conda env list --json&quot;,&#10;                &quot;/opt/anaconda3/bin/conda env list --json&quot;,&#10;                &quot;~/anaconda3/bin/conda env list --json&quot;,&#10;                &quot;~/miniconda3/bin/conda env list --json&quot;&#10;            ]&#10;&#10;            output = &quot;&quot;&#10;            error = &quot;&quot;&#10;            &#10;            for cmd in commands:&#10;                logging.debug(f&quot;尝试命令: {cmd}&quot;)&#10;                try:&#10;                    stdin, stdout, stderr = self.client.exec_command(cmd, timeout=10)&#10;                    output = stdout.read().decode('utf-8', errors='ignore').strip()&#10;                    error = stderr.read().decode('utf-8', errors='ignore').strip()&#10;                    &#10;                    logging.debug(f&quot;输出长度: {len(output)}, 错误长度: {len(error)}&quot;)&#10;                    &#10;                    if output:&#10;                        # 查找 JSON 起始位置，忽略可能的 shell 输出&#10;                        json_start = output.find('{')&#10;                        if json_start &gt;= 0:&#10;                            output = output[json_start:]&#10;                            &#10;                            data = json.loads(output)&#10;                            envs = data.get('envs', [])&#10;                            &#10;                            logging.info(f&quot;成功解析，找到 {len(envs)} 个环境&quot;)&#10;                            self.finished.emit(True, envs, &quot;&quot;)&#10;                            return&#10;                &#10;                except json.JSONDecodeError as je:&#10;                    logging.warning(f&quot;JSON 解析失败，尝试下一个命令: {je}&quot;)&#10;                    continue&#10;                except Exception as e:&#10;                    logging.debug(f&quot;命令 '{cmd}' 执行失败: {e}&quot;)&#10;                    continue&#10;            &#10;            # 如果所有命令都失败&#10;            if not output and error:&#10;                logging.error(f&quot;所有命令都失败，最终错误: {error}&quot;)&#10;                self.finished.emit(False, [], error)&#10;            else:&#10;                # 成功执行但没有环境&#10;                logging.info(&quot;命令执行成功但未找到任何环境&quot;)&#10;                self.finished.emit(True, [], &quot;&quot;)  # 成功但无环境&#10;&#10;        except Exception as e:&#10;            logging.error(f&quot;获取环境列表时发生异常: {str(e)}&quot;)&#10;            self.finished.emit(False, [], str(e))&#10;&#10;&#10;class ConfigVerifyWorker(QObject):&#10;    &quot;&quot;&quot;验证 Linux 项目配置的 Worker&quot;&quot;&quot;&#10;    finished = pyqtSignal(bool, str)  # 成功标志, 消息&#10;&#10;    def __init__(self, client, project_path: str, conda_env_path: str):&#10;        super().__init__()&#10;        self.client = client&#10;        self.project_path = project_path&#10;        self.conda_env_path = conda_env_path&#10;&#10;    @pyqtSlot()&#10;    def run(self):&#10;        try:&#10;            logging.info(f&quot;开始验证配置: 项目路径={self.project_path}, Conda环境={self.conda_env_path}&quot;)&#10;            &#10;            # 验证项目路径是否存在&#10;            cmd = f&quot;test -d '{self.project_path}' &amp;&amp; echo 'EXISTS' || echo 'NOT_EXISTS'&quot;&#10;            stdin, stdout, stderr = self.client.exec_command(cmd, timeout=10)&#10;            result = stdout.read().decode('utf-8', errors='ignore').strip()&#10;            &#10;            if 'NOT_EXISTS' in result:&#10;                self.finished.emit(False, &quot;项目路径不存在&quot;)&#10;                return&#10;            &#10;            # 验证 conda 环境是否存在&#10;            cmd = f&quot;test -d '{self.conda_env_path}' &amp;&amp; echo 'EXISTS' || echo 'NOT_EXISTS'&quot;&#10;            stdin, stdout, stderr = self.client.exec_command(cmd, timeout=10)&#10;            result = stdout.read().decode('utf-8', errors='ignore').strip()&#10;            &#10;            if 'NOT_EXISTS' in result:&#10;                self.finished.emit(False, &quot;Conda 环境不存在&quot;)&#10;                return&#10;            &#10;            # 验证 conda 环境中是否有 python&#10;            python_path = f&quot;{self.conda_env_path}/bin/python&quot;&#10;            cmd = f&quot;test -f '{python_path}' &amp;&amp; echo 'EXISTS' || echo 'NOT_EXISTS'&quot;&#10;            stdin, stdout, stderr = self.client.exec_command(cmd, timeout=10)&#10;            result = stdout.read().decode('utf-8', errors='ignore').strip()&#10;            &#10;            if 'NOT_EXISTS' in result:&#10;                self.finished.emit(False, &quot;Conda 环境无效(缺少python)&quot;)&#10;                return&#10;            &#10;            logging.info(&quot;配置验证成功&quot;)&#10;            self.finished.emit(True, &quot;验证成功&quot;)&#10;            &#10;        except Exception as e:&#10;            logging.error(f&quot;验证配置时发生异常: {str(e)}&quot;)&#10;            self.finished.emit(False, str(e))&#10;&#10;&#10;class LinuxSettingsCard(QFrame):&#10;    &quot;&quot;&quot;Linux 项目与运行环境配置卡片。&#10;    &#10;    功能：&#10;      - 配置远程 Linux 项目的根路径。&#10;      - 自动拉取并选择远程 Conda 环境。&#10;      - 生成并同步 config.env 配置文件到服务器。&#10;    &quot;&quot;&quot;&#10;&#10;    request_save = pyqtSignal()&#10;&#10;    def __init__(self, parent=None):&#10;        super().__init__(parent)&#10;        self.setObjectName(&quot;LinuxSettingsCard&quot;)&#10;        &#10;        self.active_client = None  # 存储由外部（如 SettingsPage）传入的 SSHClient&#10;        self._is_locked = False&#10;        self._fetching = False  # 添加标志来跟踪是否正在获取环境&#10;        self._in_edit_mode = False  # 添加编辑模式标志&#10;        self._external_lock = False  # 添加外部锁定标志&#10;        &#10;        # 配置恢复相关&#10;        self._pending_conda_env = &quot;&quot;  # 待恢复的 conda 环境路径&#10;        self._pending_conda_env_name = &quot;&quot;  # 待恢复的 conda 环境名称&#10;        self._needs_auto_verify = False  # 是否需要自动验证&#10;&#10;        # 自动折叠定时器&#10;        self._auto_fold_timer = QTimer(self)&#10;        self._auto_fold_timer.setSingleShot(True)&#10;        self._auto_fold_timer.timeout.connect(self._auto_fold)&#10;&#10;        self._build_ui()&#10;        self._lock_inputs()  # 默认锁定状态&#10;&#10;    def _build_ui(self) -&gt; None:&#10;        self.setStyleSheet(CARD_FRAME(&quot;LinuxSettingsCard&quot;))&#10;&#10;        main_layout = QVBoxLayout(self)&#10;        main_layout.setContentsMargins(0, 0, 0, 0)&#10;        main_layout.setSpacing(0)&#10;&#10;        # 头部区域 (可点击折叠/展开)&#10;        self.header_area = ClickableHeader()&#10;        self.header_area.setStyleSheet(&quot;background: transparent; border: none;&quot;)&#10;        self.header_area.clicked.connect(self._toggle_container)&#10;&#10;        header_layout = QHBoxLayout(self.header_area)&#10;        header_layout.setContentsMargins(20, 15, 20, 15)&#10;&#10;        self.title_label = QLabel(&quot;Linux 端运行环境配置&quot;)&#10;        self.title_label.setStyleSheet(CARD_TITLE)&#10;&#10;        self.modify_btn = QPushButton(&quot;修改&quot;)&#10;        self.modify_btn.setFixedWidth(60)&#10;        self.modify_btn.setStyleSheet(BUTTON_LINK)&#10;        self.modify_btn.clicked.connect(self._enable_editing)&#10;&#10;        self.arrow_label = QLabel(&quot;▲&quot;)&#10;        self.arrow_label.setStyleSheet(&quot;color: #90adca; font-size: 12px;&quot;)&#10;&#10;        header_layout.addWidget(self.title_label)&#10;        header_layout.addStretch()&#10;        header_layout.addWidget(self.modify_btn)&#10;        header_layout.addWidget(self.arrow_label)&#10;        main_layout.addWidget(self.header_area)&#10;&#10;        # 容器布局&#10;        self.container = QWidget()&#10;        self.container.setStyleSheet(&quot;background: transparent;&quot;)&#10;        c_layout = QVBoxLayout(self.container)&#10;        c_layout.setContentsMargins(20, 0, 20, 20)&#10;&#10;        # 表单布局&#10;        form = QFormLayout()&#10;        form.setVerticalSpacing(15)&#10;&#10;        # 1. Linux 项目根路径&#10;        self.linux_project_path = QLineEdit()&#10;        self.linux_project_path.setStyleSheet(INPUT_LINEEDIT)&#10;        self.linux_project_path.setPlaceholderText(&quot;例如: /home/zyserver/bioinfo-platform&quot;)&#10;&#10;        # 2. Conda 环境下拉框&#10;        self.conda_combo = QComboBox()&#10;        self.conda_combo.setPlaceholderText(&quot;请先连接服务器并获取列表...&quot;)&#10;        self.conda_combo.setEnabled(False)&#10;        # 使用 styles.py 中定义的 INPUT_COMBOBOX 样式&#10;        self.conda_combo.setStyleSheet(INPUT_COMBOBOX)&#10;&#10;        form.addRow(&quot;项目根路径&quot;, self.linux_project_path)&#10;        form.addRow(&quot;Conda 环境&quot;, self.conda_combo)&#10;        c_layout.addLayout(form)&#10;&#10;        # 按钮与状态行&#10;        row = QHBoxLayout()&#10;        self.fetch_btn = QPushButton(&quot;获取远程环境&quot;)&#10;        self.fetch_btn.setFixedWidth(110)&#10;        self.fetch_btn.setStyleSheet(BUTTON_PRIMARY)&#10;        self.fetch_btn.setEnabled(False)&#10;        self.fetch_btn.clicked.connect(self._on_fetch_envs)&#10;&#10;        self.lock_btn = QPushButton(&quot;确认并锁定&quot;)&#10;        self.lock_btn.setFixedWidth(110)&#10;        self.lock_btn.setStyleSheet(BUTTON_PRIMARY)&#10;        self.lock_btn.clicked.connect(self._on_save_and_lock)&#10;&#10;        self.status_label = QLabel(&quot;等待 SSH 连接&quot;)&#10;        self.status_label.setStyleSheet(STATUS_NEUTRAL)&#10;&#10;        row.addWidget(self.fetch_btn)&#10;        row.addWidget(self.lock_btn)&#10;        row.addWidget(self.status_label)&#10;        row.addStretch()&#10;        c_layout.addLayout(row)&#10;&#10;        main_layout.addWidget(self.container)&#10;&#10;    def set_active_client(self, client) -&gt; None:&#10;        &quot;&quot;&quot;接收外部传入的 SSH 客户端实例。&quot;&quot;&quot;&#10;        self.active_client = client&#10;        connected = client is not None&#10;        &#10;        self.fetch_btn.setEnabled(connected and not self._is_locked)&#10;        self.lock_btn.setEnabled(connected)&#10;        &#10;        if connected:&#10;            self.status_label.setText(&quot;SSH 已就绪&quot;)&#10;            self.status_label.setStyleSheet(STATUS_SUCCESS)&#10;            &#10;            # 如果有待验证的配置，自动执行验证&#10;            if self._needs_auto_verify and self._pending_conda_env:&#10;                QTimer.singleShot(500, self._auto_verify_config)&#10;        else:&#10;            self.status_label.setText(&quot;等待 SSH 连接&quot;)&#10;            self.status_label.setStyleSheet(STATUS_NEUTRAL)&#10;            self.conda_combo.clear()&#10;            self.conda_combo.setEnabled(False)&#10;    &#10;    def _auto_verify_config(self) -&gt; None:&#10;        &quot;&quot;&quot;自动验证已保存的配置，验证成功后锁定并折叠&quot;&quot;&quot;&#10;        if not self.active_client or not self._pending_conda_env:&#10;            return&#10;        &#10;        self.status_label.setText(&quot;正在验证配置...&quot;)&#10;        self.status_label.setStyleSheet(STATUS_NEUTRAL)&#10;        &#10;        # 创建验证线程&#10;        self._verify_thread = QThread()&#10;        self._verify_worker = ConfigVerifyWorker(&#10;            self.active_client, &#10;            self.linux_project_path.text().strip(),&#10;            self._pending_conda_env&#10;        )&#10;        self._verify_worker.moveToThread(self._verify_thread)&#10;        &#10;        self._verify_thread.started.connect(self._verify_worker.run)&#10;        self._verify_worker.finished.connect(self._on_verify_finished)&#10;        self._verify_worker.finished.connect(self._cleanup_verify_resources)&#10;        &#10;        self._verify_thread.start()&#10;    &#10;    def _cleanup_verify_resources(self):&#10;        &quot;&quot;&quot;清理验证线程资源&quot;&quot;&quot;&#10;        if hasattr(self, '_verify_thread') and self._verify_thread:&#10;            if self._verify_thread.isRunning():&#10;                self._verify_thread.quit()&#10;                self._verify_thread.wait(5000)&#10;            self._verify_thread.deleteLater()&#10;            try:&#10;                delattr(self, '_verify_thread')&#10;            except AttributeError:&#10;                pass&#10;        &#10;        if hasattr(self, '_verify_worker') and self._verify_worker:&#10;            self._verify_worker.deleteLater()&#10;            try:&#10;                delattr(self, '_verify_worker')&#10;            except AttributeError:&#10;                pass&#10;    &#10;    def _on_verify_finished(self, success: bool, message: str) -&gt; None:&#10;        &quot;&quot;&quot;配置验证完成回调&quot;&quot;&quot;&#10;        self._needs_auto_verify = False&#10;        &#10;        if success:&#10;            # 验证成功，确保 conda 环境正确显示在下拉框中&#10;            if self._pending_conda_env:&#10;                # 检查下拉框中是否已有该项&#10;                found_index = -1&#10;                for i in range(self.conda_combo.count()):&#10;                    if self.conda_combo.itemData(i) == self._pending_conda_env:&#10;                        found_index = i&#10;                        break&#10;                &#10;                if found_index &gt;= 0:&#10;                    self.conda_combo.setCurrentIndex(found_index)&#10;                else:&#10;                    # 如果没有找到，添加它&#10;                    self.conda_combo.clear()&#10;                    self.conda_combo.addItem(self._pending_conda_env_name, self._pending_conda_env)&#10;                    self.conda_combo.setCurrentIndex(0)&#10;            &#10;            # 自动锁定&#10;            self._is_locked = True&#10;            self.linux_project_path.setEnabled(False)&#10;            self.conda_combo.setEnabled(False)&#10;            self.fetch_btn.setEnabled(False)&#10;            self.lock_btn.setText(&quot;修改配置&quot;)&#10;            &#10;            self.status_label.setText(&quot;配置验证成功&quot;)&#10;            self.status_label.setStyleSheet(STATUS_SUCCESS)&#10;            &#10;            # 自动折叠（延迟执行，给用户看到成功状态）&#10;            self._auto_fold_timer.start(1500)&#10;        else:&#10;            # 验证失败，保持展开状态让用户修改&#10;            self.status_label.setText(f&quot;验证失败: {message}&quot;)&#10;            self.status_label.setStyleSheet(STATUS_ERROR)&#10;            self.conda_combo.setEnabled(True)&#10;            self.fetch_btn.setEnabled(True)&#10;            self._pending_conda_env = &quot;&quot;&#10;            self._pending_conda_env_name = &quot;&quot;&#10;&#10;    def _on_fetch_envs(self) -&gt; None:&#10;        &quot;&quot;&quot;执行远程命令获取 Conda 环境列表。&quot;&quot;&quot;&#10;        if not self.active_client or self._fetching or self._external_lock:&#10;            return&#10;&#10;        # 首先更新UI状态&#10;        self.status_label.setText(&quot;正在同步环境 (后台运行)...&quot;)&#10;        self.fetch_btn.setEnabled(False)&#10;        self._fetching = True&#10;&#10;        # 确保之前的线程已经完全清理&#10;        if hasattr(self, '_thread') and self._thread:&#10;            if self._thread.isRunning():&#10;                self._thread.quit()&#10;                self._thread.wait(3000)  # 等待最多3秒&#10;            self._thread.deleteLater()&#10;        &#10;        if hasattr(self, '_worker') and self._worker:&#10;            self._worker.deleteLater()&#10;&#10;        # 创建新线程和worker&#10;        self._thread = QThread()&#10;        self._worker = EnvFetchWorker(self.active_client)&#10;        self._worker.moveToThread(self._thread)&#10;&#10;        # 信号绑定 - 在启动前连接&#10;        self._thread.started.connect(self._worker.run)&#10;        &#10;        # 断开之前的信号连接（如果存在），然后连接新的信号&#10;        try:&#10;            self._worker.finished.disconnect()&#10;        except:&#10;            pass  # 如果没有连接的信号，则忽略异常&#10;        &#10;        self._worker.finished.connect(self._on_fetch_finished)&#10;        self._worker.finished.connect(self._cleanup_fetch_resources)&#10;&#10;        # 启动线程&#10;        self._thread.start()&#10;&#10;    def _cleanup_fetch_resources(self):&#10;        &quot;&quot;&quot;独立的资源清理方法&quot;&quot;&quot;&#10;        # 从主线程中清理资源&#10;        if hasattr(self, '_thread') and self._thread:&#10;            if self._thread.isRunning():&#10;                self._thread.quit()&#10;                self._thread.wait(5000)  # 等待最多5秒&#10;            self._thread.deleteLater()&#10;            try:&#10;                delattr(self, '_thread')&#10;            except AttributeError:&#10;                pass  # 如果属性已被删除，则忽略&#10;            &#10;        if hasattr(self, '_worker') and self._worker:&#10;            self._worker.deleteLater()&#10;            try:&#10;                delattr(self, '_worker')&#10;            except AttributeError:&#10;                pass  # 如果属性已被删除，则忽略&#10;&#10;    def _on_fetch_finished(self, success, envs, error_msg):&#10;        &quot;&quot;&quot;线程结束后的回调&quot;&quot;&quot;&#10;        # 确保在主线程中执行，避免竞态条件&#10;        if hasattr(self, '_fetching') and self._fetching:&#10;            self._fetching = False&#10;            self.fetch_btn.setEnabled(True)&#10;&#10;        if success:&#10;            self.conda_combo.clear()&#10;            for path in envs:&#10;                name = path.split('/')[-1] if '/' in path else path&#10;                self.conda_combo.addItem(name, path)&#10;            self.conda_combo.setEnabled(True)&#10;            self.status_label.setText(f&quot;成功获取 {len(envs)} 个环境&quot;)&#10;            self.status_label.setStyleSheet(STATUS_SUCCESS)&#10;        else:&#10;            self.status_label.setText(f&quot;获取失败: {error_msg[:20]}...&quot;)&#10;            self.status_label.setStyleSheet(STATUS_ERROR)&#10;&#10;    def _on_save_and_lock(self) -&gt; None:&#10;        &quot;&quot;&quot;生成远程 config.env 并切换锁定状态。&quot;&quot;&quot;&#10;        if self._is_locked:&#10;            # 解锁逻辑&#10;            self._is_locked = False&#10;            self.linux_project_path.setEnabled(True)&#10;            self.conda_combo.setEnabled(True)&#10;            self.fetch_btn.setEnabled(True)&#10;            self.lock_btn.setText(&quot;确认并锁定&quot;)&#10;            self.status_label.setText(&quot;配置已解锁&quot;)&#10;            return&#10;&#10;        # 锁定逻辑&#10;        project_path = self.linux_project_path.text().strip()&#10;        env_path = self.conda_combo.currentData()&#10;&#10;        if not project_path or not env_path:&#10;            self.status_label.setText(&quot;请填写路径并选择环境&quot;)&#10;            self.status_label.setStyleSheet(STATUS_ERROR)&#10;            return&#10;&#10;        try:&#10;            # 远程写入配置&#10;            config_content = f&quot;CONDA_ENV_PATH={env_path}\\nPROJECT_ROOT={project_path}&quot;&#10;            # 创建 config 目录并写入 config.env&#10;            cmd = f&quot;mkdir -p {project_path}/config &amp;&amp; echo -e '{config_content}' &gt; {project_path}/config/config.env&quot;&#10;            self.active_client.exec_command(cmd)&#10;&#10;            self._is_locked = True&#10;            self.linux_project_path.setEnabled(False)&#10;            self.conda_combo.setEnabled(False)&#10;            self.fetch_btn.setEnabled(False)&#10;            self.lock_btn.setText(&quot;修改配置&quot;)&#10;            &#10;            self.status_label.setText(&quot;远程配置已生成并锁定&quot;)&#10;            self.status_label.setStyleSheet(STATUS_SUCCESS)&#10;            self.request_save.emit()&#10;        except Exception as e:&#10;            self.status_label.setText(f&quot;保存失败: {str(e)}&quot;)&#10;            self.status_label.setStyleSheet(STATUS_ERROR)&#10;&#10;    def get_values(self) -&gt; dict:&#10;        &quot;&quot;&quot;供 SettingsPage 获取数据。&quot;&quot;&quot;&#10;        return {&#10;            &quot;linux_project_path&quot;: self.linux_project_path.text().strip(),&#10;            &quot;conda_env_path&quot;: self.conda_combo.currentData() or &quot;&quot;,&#10;            &quot;conda_env_name&quot;: self.conda_combo.currentText() or &quot;&quot;,  # 保存显示名称&#10;            &quot;is_locked&quot;: self._is_locked&#10;        }&#10;&#10;    def set_values(self, project_path: str = &quot;&quot;, conda_env: str = &quot;&quot;, conda_env_name: str = &quot;&quot;) -&gt; None:&#10;        &quot;&quot;&quot;供 SettingsPage 回填数据。&quot;&quot;&quot;&#10;        self.linux_project_path.setText(project_path)&#10;        # 保存待恢复的 conda 环境配置&#10;        self._pending_conda_env = conda_env&#10;        self._pending_conda_env_name = conda_env_name or (conda_env.split('/')[-1] if conda_env else &quot;&quot;)&#10;        &#10;        # 如果已有 conda 环境配置，先添加一个占位项显示&#10;        if conda_env and self._pending_conda_env_name:&#10;            self.conda_combo.clear()&#10;            self.conda_combo.addItem(self._pending_conda_env_name, conda_env)&#10;            self.conda_combo.setCurrentIndex(0)&#10;            self.conda_combo.setEnabled(False)  # 等待验证后启用&#10;        &#10;        # 标记需要自动验证&#10;        self._needs_auto_verify = bool(project_path and conda_env)&#10;&#10;    def _toggle_container(self):&#10;        &quot;&quot;&quot;折叠/展开&quot;&quot;&quot;&#10;        if self._fetching or self._external_lock:&#10;            return&#10;        visible = self.container.isVisible()&#10;        self.container.setVisible(not visible)&#10;        self.arrow_label.setText(&quot;▲&quot; if not visible else &quot;▼&quot;)&#10;&#10;    def _auto_fold(self):&#10;        &quot;&quot;&quot;自动折叠，仅在锁定且可见时触发&quot;&quot;&quot;&#10;        if not self._in_edit_mode and self.container.isVisible():&#10;            self.container.hide()&#10;            self.arrow_label.setText(&quot;▼&quot;)&#10;&#10;    def _enable_editing(self):&#10;        &quot;&quot;&quot;进入编辑模式：解锁输入框，修改按钮保持可见，显示保存按钮&quot;&quot;&quot;&#10;        if self._external_lock:&#10;            return&#10;        self.container.show()&#10;        self.arrow_label.setText(&quot;▲&quot;)&#10;&#10;        self.linux_project_path.setEnabled(True)&#10;        self.conda_combo.setEnabled(True)&#10;&#10;        self.lock_btn.show()&#10;        self.lock_btn.setEnabled(True)&#10;        self.modify_btn.show()  # 修改按钮保持可见&#10;&#10;        self.status_label.setText(&quot;请修改配置并保存&quot;)&#10;        self.status_label.setStyleSheet(STATUS_NEUTRAL)&#10;        self._in_edit_mode = True&#10;&#10;    def _lock_inputs(self):&#10;        &quot;&quot;&quot;锁定模式：禁用输入框，修改按钮保持可见&quot;&quot;&quot;&#10;        self.linux_project_path.setEnabled(False)&#10;        self.conda_combo.setEnabled(False)&#10;&#10;        self.lock_btn.setText(&quot;修改配置&quot;)&#10;        self.modify_btn.show()  # 修改按钮始终保持可见&#10;        if self._is_locked:&#10;            self.status_label.setText(&quot;配置已保存&quot;)&#10;        else:&#10;            self.status_label.setText(&quot;等待配置&quot;)&#10;        self._in_edit_mode = False&#10;&#10;    def set_external_lock(self, locked: bool) -&gt; None:&#10;        &quot;&quot;&quot;外部锁定功能，用于在SSH连接被占用时禁用编辑&quot;&quot;&quot;&#10;        if self._external_lock == locked:&#10;            return&#10;        self._external_lock = locked&#10;        self._refresh_interaction_state()&#10;&#10;    def _refresh_interaction_state(self) -&gt; None:&#10;        &quot;&quot;&quot;刷新交互状态，处理外部锁定等情况&quot;&quot;&quot;&#10;        if self._external_lock:&#10;            for w in [self.linux_project_path, self.conda_combo, self.modify_btn, self.lock_btn]:&#10;                w.setEnabled(False)&#10;            return&#10;&#10;        if self._fetching:&#10;            return&#10;&#10;        if self._in_edit_mode:&#10;            self.linux_project_path.setEnabled(True)&#10;            self.conda_combo.setEnabled(True)&#10;            self.lock_btn.setEnabled(True)&#10;            self.modify_btn.setEnabled(True)&#10;        else:&#10;            self.linux_project_path.setEnabled(False)&#10;            self.conda_combo.setEnabled(False)&#10;            self.modify_btn.setEnabled(True)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>